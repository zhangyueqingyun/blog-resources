# 数组
在 v8 内部， 数组由两种表现形式，一种是快数组，一种是慢数组。快速的后备存储结构是 FixeArray ，并且数组长度 <= elements.length 

fast：快速数组的后备存储结构是 FixedArr，数组长度 <= elements.length()

slow：缓慢的后备存储结构是 HashTable 。

## Fast Elements 
快数组是一种线性的存储方式。新创建的空数组，默认的存储方式是快数组，快数组长度是可变的，可以根据元素的增加和删除来动态调整存储空间的大小，内部是通过扩容和收缩机制实现.

扩容后的新容量 = 旧容量的1.5倍 + 16，扩容后会将数组拷贝到新的内存空间中。

如果容量 >= length 的 2 倍 + 16，则进行收缩容量调整，否则使用 holes 对象填充未被初始化的位置。

holes （空洞）对象指的是数组中分配了空间，但是没有存放元素的位置。
Fast Holey Elements 模式适合于数组中的 holes (空洞)情况，即只有某些索引存有数据，而其他的索引都没有赋值的情况。

当数组中有空洞，没有赋值的数组索引将存储特殊值，得到undefined。

Fast Holey Element 模式与 Fast Elements 模式一样，会动态分配连续的存储空间，分配空间的大小由最大的索引值决定。

新建数组时，如果没有设置容量，V8 会默认使用 Fast Elements 模式实现。如果对数组设置容量，但并没有进行内部元素初始化，数组内部就出现了空洞，就用 Fast Holey Elements 模式实现。

## 慢数组
慢数组是一种字典的内存形式，不用开辟大块连续的内存空间，节省了内存，但是由于需要维护一个 HashTable，其效率会比快数组低。

## 快数组，慢数组的区别
- 存储方式方面：快数组内存中是连续的，慢数组在内存中是零散分配的。
- 内存使用方面：由于快数组内存是连续的，可能需要开辟一大块供其使用，其中还有很多空洞，是比较浪费内存的，慢数组不会有空洞的情况，且都是零散的内存，比较节省内存空间。
- 遍历效率方面：快数组由于是空间连续的，遍历很快，而慢数组每次都要寻找 key 的位置，遍历效率会差一点。

## 快慢数组之间的转换
当新容量 >= 3 * 扩容后的容量 * 2，会转变为慢数组，当加入的 index - 当前 capacity >= kMaxGap(1024) 时（也就是至少有了1024个空洞），会转变为慢数组。

当慢数组的元素可存放在快数组中且长度在 smi 之间且仅节省了 50% 的空间，则会转变为快数组。（当空洞元素减少到一定程度，则会将其转化为快数组的模式）。
## 各有优势
快数组就是以空间换时间的方式，申请了大块连续内存，提高效率。慢数组以事件换空间，不必申请连续的空间，节省了内存，但需要付出效率变差的代价。
## 总结
JS 的数组看似与传统数组不一样，其实只是在 v8 的底层实现上做了一层封装，使用两种数据结构实现数组，通过时间和空间维度的取舍，优化数组的性能。



