# 执行流程

## 一、前情提要
如何初始化一个 Vue 项目？
~~~javascript
import Vue from 'vue'
Vue.createApp().mount()
~~~
## 二、 追溯远码
Vue 包的引入：
~~~javascript
import Vue from 'vue'
~~~
Vue.createApp 调用 'vue' 包导出的 createApp 方法。
~~~typescript
/**
 * module   : vue
 * filepath : src/index.ts
 * linenum  : 90
 */

export * from '@vue/runtime-dom'
~~~
createApp
- createApp 的源码位于 'runtime-dom' 包中。
- createApp 通过 ensureRenderer 调用 'runtime-core' 包中的 createRenderer 获取 Vue app 实例。
- 包装 app.mount。
- 返回 app 实例。 
~~~typescript
/**
 * module   : runtime-dom
 * filepath : src/index.ts  
 */

// linenum  : 1
import {
    createRenderer
} from '@vue/runtime-core'

// linenum  : 42
function ensureRenderer() {
    renderer || (renderer = createRenderer<Node,Element | ShadowRoot>(rendererOptions))
}

// linenum  : 66
export const createApp = ((...args) -> {
    const app = ensureRenderer().createApp(...args)
    const {mount} = app
    app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector)
        if(!container) return
        const component = app._component
        if(!isFunction(component) && !component.render && component.template) {
            component.template = container.innerHTML
        }
        component.innerHTML = ''
        const proxy = mount(container, false, container instanceof SVGElement)
        return proxy
    }
    return app
})
~~~
createRenderer 位于 'runtime-core' 包的 renderer.ts 文件中，它又调用了同文件内的 baseCreateRenderer 函数。

baseCreateRenderer 函数内部实现了 vnode 挂载逻辑、 patch 流程和 diff 算法。
~~~typescript
/**
 * module   : runtime-core
 * filepath : src/renderer.ts  
 */

// linenum  : 292
export function createRenderer<
    HostNode = RendererNode,
    HostElement = RendererElement
>(options: RendererOptions<HostNode, HostElement>){
    return baseCreateRenderer<HostNode, HostElement>(options)
}

// linenum : 321
function baseCreateRenderer(
    options: RendererOptions,
    createHydrationFns?: typeof createHydrationFunctions
): any {

    /* ... */

    // linenum: 354
    const patch: PatchFn = (
        n1,
        n2,
        container,
        anchor = null,
        parentComponent = null,
        parentSuspense = null,
        isSVG = false,
        slotScopeIds = null,
        optimized = __DEV__ && isHmrUpdating ? false : !!n2.dynamicChildren
    ) => { /* ... */ }

    /* ... */

    // linenum : 2326
    const render: RootRenderFunction = (vnode, container, isSVG) => {
        if(vnode == null) {
            if(container._vnode) {
                unmount(container._vnode, null, null, true)
            }
        } else {
            patch(container._vnode || null, vnode, container, null, null, null, isSVG)
        }
        flushPostFlushCbs()
        container._vnode = vnode
    }

    // linenum : 2359
    return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
    }
}
~~~
patch 函数比较两个新旧节点。
- 当旧节点和新节点完全相同时，不做任何处理。
- 当旧节点和新节点不同类型时，卸载旧节点。
- 当新节点的 patchFlag 是 BAIL 时，关闭优化模式。
- 当新节点的类型是 Text 时，调用 processText 函数。
- 当新节点的类型是 Comment （注释）时，调用 processCommentNode 函数。
- 当新节点的类型是 Static 时，如果旧节点不存在，则调用 mountStaticNode 函数。
- 当新节点是 Fragment 时，调用 processFragment 函数。
- 当新节点是 ELEMENT（HTML 元素）类型时，调用 processElement 函数。
- 当新节点是 Component （Vue3 组件）类型时，调用 processComponent 函数。
- 当新节点是 Teleport 类型时，调用 n2.type.process 函数。
- 当新节点是 Suspense 类型时，调用 n2.type.process 函数。
~~~typescript
/**
 * module   : runtime-core
 * filepath : src/renderer.ts  
 */

// linenum : 321
function baseCreateRenderer(
    options: RendererOptions,
    createHydrationFns?: typeof createHydrationFunctions
): any {

    /* ... */

    // linenum : 354
    const patch: PatchFn = (
        n1,
        n2,
        container,
        anchor = null,
        parentComponent = null,
        parentSuspense = null,
        isSVG = false,
        slotScopeIds = null,
        optimized = __DEV__ && isHmrUpdating ? false : !!n2.dynamicChildren
    ) => {
        if(n1 === n2) {
            return
        } 

        if(n1 && !isSameVNodeType(n1, n2)){
            anchor = getNextHostNode(n1)
            unmount(n1, parentComponent, parentSuspense, true)
            n1 = null
        }

        /* ... */ 

        // linenum : 381
        const {type, ref, shapeFlag} = n2
        switch(type) {
            case Text:
                processText(n1, n2, container, anchor)
                break
            case Comment:
                processCommentNode(n1, n2, container, anchor)
                break
            case Static:
                if(n1 == null) {
                    mountStaticNode(n2, container, anchor, isSVG)
                } else if (__DEV__){
                    patchStaticNode(n1, n2, container, isSVG)
                }
                break
            case Fragment:
                processFragment(
                    n1,
                    n2,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    isSVG,
                    slotScopeIds,
                    optimized
                )
                break
            default:
                if(shapeFlag & ShapeFlags.ELEMENT) {
                    processElement(
                        n1,
                        n2,
                        container,
                        anchor,
                        parentComponent,
                        parentSuspense,
                        isSVG,
                        slotScopeIds,
                        optimized
                    )
                } else if (shapeFlag & ShapeFlags.COMPONENT) {
                    processComponent(
                        n1,
                        n2,
                        container,
                        anchor,
                        parentComponent,
                        parentSuspense,
                        isSVG,
                        slotScopeIds,
                        optimized
                    )
                } else if (shapeFlag & ShapeFalgs.TELEPORT) {
                    ;(type as typeof TeleportImpl).process(
                        n1 as TeleportVNode,
                        n2 as TeleportVNode,
                        container,
                        anchor,
                        parentComponent,
                        parentSuspense,
                        isSVG,
                        slotScopeIds,
                        optimized,
                        internals
                    )
                } else if (__FEATURE_SUSPENSE__ && shapeFlag & ShapeFlags.SUSPENSE) {
                    ;(type as typeof SuspenseImpl).process(
                        n1,
                        n2,
                        container,
                        anchor,
                        parentComponent,
                        parentSuspense,
                        isSVG,
                        slotScopeIds,
                        optimized,
                        internals
                    )
                } else if (__DEV__) {
                    warn('Invalid VNode type:', type, `(${typeof type})`)
                }
        }
    }
}
~~~
processElement 
- 当源节点不存在时，直接挂载新节点。
- 当源节点存在时，调用 patchElement 函数
~~~typescript
const processElement = (
    n1: VNode | null,
    n2: VNode,
    container: RendererElement,
    anchor: RendererNode | null,
    parentComponent: ComponentInternalInstance | null,
    parentSuspense: SuspenseBoundary | null,
    isSVG: boolean,
    slotScopeIds: string[] | null,
    optimized: boolean
) => {
    isSVG = isSVG || (n2.type as string) === 'svg'
    if(n1 == null) {
        mountElement(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
        )
    } else {
        patchElement(
            n1,
            n2,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
        )
    }
}
~~~
patchElement
- 触发钩子
- 更新属性
- 更新子节点
~~~typescript
const patchElement = (
    n1: VNode,
    n2: VNode,
    parentComponent: ComponentInternalInstance | null,
    parentSuspense: SuspenseBoundary | null,
    isSVG: boolean,
    slotScopeIds: string[] | null,
    optimized: boolean
) => {
    const el = (n2.el = n1.el)
    let {patchFlag, dynamicChildren, dirs} = n2
    patchFlag |= n1.patchFlag & PatchFlags.FULL_PROPS
    const oldProps = n1.props || EMPTY_OBJ  
    const newProps = n2.props || EMPTY_OBJ
    let vnodeHook: VNodeHook | undefined | null

    parentComponent && toggleRecurse(parentComponent, false)
    if((vnodeHook = newProps.onVnodeBeforeUpdate)) {
        invokeVNodeHook(vnodeHook, parentComponent, n2, n1)
    }
    if(dirs) {
        invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate')
    }
    parentComponent && toggleRecurse(parentComponent, true)

    const areChildrenSVG = isSVG && n2.type !== 'foreignObject'
    if(dynamicChildren) {
        patchBlockChildren(
            n1.dynamicChildren!,
            dynamicChildren,
            el,
            parentComponent,
            parentSuspense,
            areChildrenSVG,
            slotScopeIds
        )
    }
}
~~~

(今天先到这里，下次追更)