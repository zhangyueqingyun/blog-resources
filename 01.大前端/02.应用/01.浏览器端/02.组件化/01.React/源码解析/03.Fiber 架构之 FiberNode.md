# React 源码解析：第三章 Fiber 架构之 FiberNode 

😆 Hi，大家好，我是张玥卿云，一个面向未来编程的程序员！准备将 React 源码解析写成一系列文章分享给大家，希望大家喜欢~ 

##  一、前言

一个最简单的 React 程序往往包含三个步骤：

1. 创建 React 元素树：

```javascript 
const element = React.createElement("div", {}, '');
```

2. 创建 FiberRoot 节点并挂载到 DOM 容器节点上：

```javascript
const root = ReactDOM.createRoot(container);
```

3. FiberRoot 渲染第一步创建的 React 元素树：

```javascript
root.render(element);
```

由于第三步元素树的渲染比较复杂，是 React 框架的重中之重，我们分成几个章节来讲解。这一章主要由 root.render() 这个 api 起始，重点讲述 Fiber 树第一次的构建。

## 二、认识 Fiber 树

什么是 Fiber 树呢？ Fiber 树是 React 内部构建的，用于渲染网页的一种内部树形结构，虽然是层级型的数据，但每个节点上的指针让访问这棵树变成了类似链表的顺序访问。

FiberNode 的每一个节点都包含了内部操作有关的信息。

## 三、Fiber 树的节点


### 3.1 FiberNode

```javascript 
function FiberNode(
  tag,
  pendingProps,
  key,
  mode,
) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.elementType = null;
  this.type = null;
  this.stateNode = null;

  // Fiber
  this.return = null;    // 父节点
  this.child = null;    // 第一个子节点
  this.sibling = null;    // 兄弟节点
  this.index = 0;

  this.ref = null;    

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;

  this.mode = mode;

  // Effects
  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.deletions = null;

  this.lanes = NoLanes;
  this.childLanes = NoLanes;

  this.alternate = null;

  if (enableProfilerTimer) {
    this.actualDuration = Number.NaN;
    this.actualStartTime = Number.NaN;
    this.selfBaseDuration = Number.NaN;
    this.treeBaseDuration = Number.NaN;

    this.actualDuration = 0;
    this.actualStartTime = -1;
    this.selfBaseDuration = 0;
    this.treeBaseDuration = 0;
  }
}
```

#### 3.2 节点类型

Fiber 节点的类型

```javascript
export const FunctionComponent = 0;    // 函数组件
export const ClassComponent = 1;    // 类组件
export const IndeterminateComponent = 2;    //中间组件 （未知是函数组件或类组件）
export const HostRoot = 3;  // Fiber 树的根节点.
export const HostPortal = 4;     // Portal 功能的节点，可能是另外一个渲染的入口.
export const HostComponent = 5;
export const HostText = 6;
export const Fragment = 7;      
export const Mode = 8;
export const ContextConsumer = 9;
export const ContextProvider = 10;
export const ForwardRef = 11;
export const Profiler = 12;
export const SuspenseComponent = 13;
export const MemoComponent = 14;
export const SimpleMemoComponent = 15;
export const LazyComponent = 16;
export const IncompleteClassComponent = 17;
export const DehydratedFragment = 18;
export const SuspenseListComponent = 19;
export const ScopeComponent = 21;
export const OffscreenComponent = 22;    // 离屏组件
export const LegacyHiddenComponent = 23;
export const CacheComponent = 24;
export const TracingMarkerComponent = 25;

```

#### 3.3 Fiber 节点模式

```javascript
export const NoMode = /*                         */ 0b000000;    // 无模式
export const ConcurrentMode = /*                 */ 0b000001;    // 并行模式
export const ProfileMode = /*                    */ 0b000010;    // 分析模式
export const DebugTracingMode = /*               */ 0b000100;    // 调式模式
export const StrictLegacyMode = /*               */ 0b001000;    
export const StrictEffectsMode = /*              */ 0b010000;
export const ConcurrentUpdatesByDefaultMode = /* */ 0b100000;
```

## 四、FiberNode 的创建

```javascript
const createFiber = function(
  tag,
  pendingProps,
  key,
  mode,
) {
  return new FiberNode(tag, pendingProps, key, mode);
};
```

#### 4.1 创建 ReactElement 对应的 Fiber
```javascript
 export function createFiberFromElement(
  element,
  mode,
  lanes,
) {
  let owner = null;
  const type = element.type;
  const key = element.key;
  const pendingProps = element.props;
  const fiber = createFiberFromTypeAndProps(
    type,
    key,
    pendingProps,
    owner,
    mode,
    lanes,
  );
  return fiber;
}

```

```javascript
export function createFiberFromTypeAndProps(
  type, // React$ElementType
  key,
  pendingProps,
  owner,
  mode,
  lanes,
) {
  let fiberTag = IndeterminateComponent;
  // The resolved type is set if we know what the final type will be. I.e. it's not lazy.
  let resolvedType = type;
  if (typeof type === 'function') {
    if (shouldConstruct(type)) {
      fiberTag = ClassComponent;
    } 
  } else if (typeof type === 'string') {
    fiberTag = HostComponent;
  } else {
    getTag: switch (type) {
      case REACT_FRAGMENT_TYPE:
        return createFiberFromFragment(pendingProps.children, mode, lanes, key);
      case REACT_STRICT_MODE_TYPE:
        fiberTag = Mode;
        mode |= StrictLegacyMode;
        if (enableStrictEffects && (mode & ConcurrentMode) !== NoMode) {
          // Strict effects should never run on legacy roots
          mode |= StrictEffectsMode;
        }
        break;
      case REACT_PROFILER_TYPE:
        return createFiberFromProfiler(pendingProps, mode, lanes, key);
      case REACT_SUSPENSE_TYPE:
        return createFiberFromSuspense(pendingProps, mode, lanes, key);
      case REACT_SUSPENSE_LIST_TYPE:
        return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
      case REACT_OFFSCREEN_TYPE:
        return createFiberFromOffscreen(pendingProps, mode, lanes, key);
      case REACT_LEGACY_HIDDEN_TYPE:
        if (enableLegacyHidden) {
          return createFiberFromLegacyHidden(pendingProps, mode, lanes, key);
        }
      // eslint-disable-next-line no-fallthrough
      case REACT_SCOPE_TYPE:
        if (enableScopeAPI) {
          return createFiberFromScope(type, pendingProps, mode, lanes, key);
        }
      // eslint-disable-next-line no-fallthrough
      case REACT_CACHE_TYPE:
        if (enableCache) {
          return createFiberFromCache(pendingProps, mode, lanes, key);
        }
      // eslint-disable-next-line no-fallthrough
      case REACT_TRACING_MARKER_TYPE:
        if (enableTransitionTracing) {
          return createFiberFromTracingMarker(pendingProps, mode, lanes, key);
        }
      // eslint-disable-next-line no-fallthrough
      case REACT_DEBUG_TRACING_MODE_TYPE:
        if (enableDebugTracing) {
          fiberTag = Mode;
          mode |= DebugTracingMode;
          break;
        }
      // eslint-disable-next-line no-fallthrough
      default: {
        if (typeof type === 'object' && type !== null) {
          switch (type.$$typeof) {
            case REACT_PROVIDER_TYPE:
              fiberTag = ContextProvider;
              break getTag;
            case REACT_CONTEXT_TYPE:
              // This is a consumer
              fiberTag = ContextConsumer;
              break getTag;
            case REACT_FORWARD_REF_TYPE:
              fiberTag = ForwardRef;
              break getTag;
            case REACT_MEMO_TYPE:
              fiberTag = MemoComponent;
              break getTag;
            case REACT_LAZY_TYPE:
              fiberTag = LazyComponent;
              resolvedType = null;
              break getTag;
          }
        }
        let info = '';

        throw new Error(
          'Element type is invalid: expected a string (for built-in ' +
            'components) or a class/function (for composite components) ' +
            `but got: ${type == null ? type : typeof type}.${info}`,
        );
      }
    }
  }

  const fiber = createFiber(fiberTag, pendingProps, key, mode);
  fiber.elementType = type;
  fiber.type = resolvedType;
  fiber.lanes = lanes;

  return fiber;
}
```

#### 4.2 其他



## 五、结尾

这些就是 FiberRoot 创建及挂载的全过程啦！ 欢迎小伙伴们一起讨论~ @V@ ~

最后来则广告 @v@~

> ✨ 布灵布灵！YQY 低代码平台首发啦！
> ---
> 
> #### 🍓 基本功能
> 
> - 通过拖拽自动生成 React 项目代码（包含路由、布局、页面、组件、css样式）。
> - 自动化生成代码仓库。
> - 自动化部署。
> - 快捷访问部署的项目、页面。
> - 通过低代码平台对已生成的项目进行修改。
> - 拉取项目至本地，由开发人员手动开发，推送到远程仓库后自动化部署。
> - 接入不同组件库。
> - 支持接入埋点、监控等前端架构。
> 
> #### 🍓 优点
> 
> - 生成的代码可读性好，包含注释。
> - 可生成不同类型的组件（函数组件、类组件）。
> - 可自动生成项目、布局、页面、路由等。
> - 支持自动创建代码仓库、自动化部署。
> - 支持接入不同组件库。
> - 支持接入埋点、监控等企业级前端架构。
> 
> 😈 如感兴趣，可联系本人：张大可爱宝宝 
> 
> - tel: 16602927079 
> - email: zhangyueqingyun@foxmail.com
> - wechat: abcde-ovo-yz
> 
> 🐼 其他
> ---
> 
> - 🍋 [个人博客](https://zhangyueqingyun.tech)
> - 🍒 [算法测试框架](https://github.com/zhangyueqingyun/algorithm)
> - 🍓 [前端原创资源](https://github.com/zhangyueqingyun/blog-resources)
