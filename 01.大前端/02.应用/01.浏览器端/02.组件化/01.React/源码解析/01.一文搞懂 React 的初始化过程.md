# 一文搞懂 React 的初始化过程

😆 Hi，大家好，我是张玥卿云，一个面向未来编程的程序员！下面将要围绕源码讲解 React 的初始化过程，希望大家喜欢 ~

##  一、概览

我们知道，一个最简单的 React 程序往往包含三个步骤：

1. 创建 React 元素树。
2. 创建 FiberRoot 节点并挂载到 DOM 容器节点上。
3. FiberRoot 渲染第一步创建的 React 元素树。

对应以下行代码：
 
```javascript
/** 创建 React 元素树 */
const element = React.createElement('div', {}, '');

/** 创建 FiberRoot 节点并挂在到 DOM 容器上 */
const root = ReactDOM.createRoot(container);

/** 由 Fiber Root 渲染元素树 */
root.render(element);
```

今天我们要讲的第一个和第二个步骤，创建 React 元素树和创建并挂载 FiberRoot 节点。   

首先我们来看看，什么是 React 元素。

## 二、React 元素 

### 2.1 一句话理解 React 元素

React 元素树是 React 使用者和 React 交互的桥梁，我们用它来告诉 React 我们想要的网站是什么样的。 React 会解析我们定义的元素树，并在在内部转化为自己的数据结构（Fiber 架构），生成交互网站。

### 2.2 源码解析

在源码中，React 元素是一个含有 $$typeof 属性的对象，由一个名为 ReactElement 的工厂函数创建。React 通过判断 $$typeof 是否等于 REACT_ELEMENT_TYPE 而确定该对象是否为 React 元素。  

React 元素具有 type，key，ref，props 四个基本属性，我们简单看下这四个基本属性：

- type 是 React 元素的类型，html 元素名，也可以为我们定义的 React 组件。
- key 是 React 元素在其同级兄弟中的的身份标志，更新 Fiber 树的时候会用它来确定 React 元素的身份，React 用它提高 Fiber 树的更新性能。
- ref 是对组件实例的引用。
- props 是 React 或 DOM 组件传递的属性值。

React 同时也具有 \_owner, \_store, \_self, \_source 三个内部属性。\_owner 属性记录了创建该元素的起因，而 \_store, \_self 和 \_source 在开发模式下才会被创建，本文不过多讲解了。

```javascript
/** 创建 React 元素的工厂函数 */
const ReactElement = function(type, key, ref, self, source, owner, props) {
	const element = {
		/** 标识该对象为 React 元素 */
		$$typeof: REACT_ELEMENT_TYPE，
		type: type,
		key: key,
		ref: ref,
		props: props,
		_owner: owner
	}

	/** ... 此处省略 DEV 模式下的若干行代码 ... */

	return element;
} 
```

## 三、React 元素的创建

我们可以通过以下几个 React 提供的 Api 创建 React 元素： 

- React.createElement
- jsx
- React.cloneElement
- React.cloneAndReplaceKey 

本文我们只分析 React.createElement 和 React.cloneElement 的源码。

### 3.1 React.createElement

React.createElement 是 React 创建 React 元素最基本的方法，它主要做了以下几件事：

1. 通过 config 形参获取 ref、key、self、 source、 props 和 props.children。
2. 根据 defaultProps 初始化 props。
3. 通过工厂函数 ReactElement 创建 React 元素。

```javascript 
export function createElement(type, config, children) {
	let propName;

	const props = {};

	let key = null;
	let ref = null;
	let self = null;
	let source = null;

	if(config != null) {

		/** 初始化 ref  */
		if(hasValidRef(config)) {
			ref = config.ref;
		}

		/** 初始化 key */
		if(hasValidKey(config)) {
			key = '' + config.key;
		}
	}

    /** 初始化 self 和 source  */
	self = config.__self === undefined ? null : config.__self;
	source = config.__source === undefined ? null : config.__source; 

	/** 初始化其他 props */
	for (propName in config) {
		if (
			hasOwnProperty.call(config, propName) && 
			!RESERVED_PROPS.hasOwnProperty(propName)
		) {
			props[propName] = config[propName];
		}
	}

	/** 初始化 children */
	const childrenLength = arguments.length - 2;
	if(childrenLength === 1) {
		props.children = children;
	} else if (childrenLength > 1) {
		const childrenArray = Array(childrenLength);
		for(let i = 0; i < childrenLength; i++) {
			childrenArray = Array(childrenLength);
		}
		props.children = childrenArray;
	}

	/** 初始化 defaultProps */
	if(type && type.defaultProps) {
		const defaultProps = type.defaultProps;
		for(propName in defaultProps) {
			if(props[Name] in defaultProps) {
				props[propName] = defaultProps[propName];
			}
		}
	}

	/** 创建 React 元素 */
	return ReactElement(
		type,
		key,
		ref,
		self,
		source,
		ReactCurrentOwner.current,
		props
	)
}
```

### 3.2 React.cloneElement 

React.cloneElement 和 React.createElement 比较相似，我们经常用它来扩展已存在的 React 元素的功能，这个 api 主要做了以下几件事：

1. 从原 React 元素中获取 props、key、ref、\_self、\_source、\_owner 属性。
2. 解析新配置，获取新的 ref、key、defaultProps 等属性并覆盖原属性。
3. 根据 defaultProps 和 props 设置默认值。
4. 获取 props.children。
5. 通过工厂函数 ReactElement 创建 React 元素并返回。

```javascript
export function cloneElement(element, config, children) {
	if(element === null || element === undefined) {
		throw new Error(`React.cloneElement(...): The argument must be a React element, but you passed ${element}`)
	}   

	let propName;

	// 获取待克隆对象的 props
	const props = assign({}, element.props);

	/** 获取待克隆对象的 key  */

	let key = element.key;
	/** 获取待克隆对象的 ref*/
	let ref = element.ref;

	/** 获取待克隆对象的 _self、 _source、_owner 属性 */
	const self = element._self;
	const source = element._source;
	let onwer = element._owner;

	/** 解析新的配置 */
	if(config != null)  {

		/** 获取新的  ref */
		if(hasValidRef(config)) {
			ref = config.ref;
			owner = ReactCurrentOwner.current;
		}

		/** 获取新的 key  */
		if(hasValidKey(config)) {
			key = '' + config.key;
		}

		/** 获取 defaultProps  */
		let defaultProps;
		if(element.type && element.type.defaultProps) {
			defaultProps = element.type.defaultProps;
		}

		/** 根据新的 defaultProps 和从被克隆元素获取的 props 初始化 props */
		for(propName in config) {
			if(
				hasOwnProperty.call(config, propName) && 
				!RESERVED_PROPS.hasOwnProperty(propName)
			) {
				if(config[propName] === undefined && defaultProps !== undefined) {
					props[propName] = defaultProps[propName];
				} else {
					props[propName] = config[propName];
				}
			}
		}

		/** 获取 children */
		const childrenLength = arguments.length - 2;
		if(chidlrenLength === 1) {
			props.children = children;
		} else if (childrenLength > 1) {
			const childArray = Array(ChildrenLength);
			for(let i = 0; i < childrenLength; i++) {
				childArray[i] = arguments[i + 2];
			}

			props.children = childArray;
		}

		/** 通过工厂函数创建 React 元素并返回 */
		return ReactElement(element.type, key, ref, self, source, owner, props);
	}
}
```

## 四、创建并挂载 FiberRoot                                               

React 通过创建 FiberRoot 并将其挂载到 DOM 容器元素上来初始化它的工作环境，对应的 Api 为 React.createRoot 。

### 4.1 React.createRoot                                                                                                                                    

React.createRoot 是创建和挂载 FiberRoot 的总控函数，它的执行流程如下：

1. 处理 options 中一些可配置的属性
2. 创建 FiberRoot 
3. 将 FiberRoot 挂载到了 DOM 容器节点上
4. 初始化 Dispatcher
5. 获取并监听该监听的 DOM 容器节点的所有事件
6. 返回 ReactDOMRoot

```javascript
export function createRoot(
	container,
	options
) {
	if(!isValidContainer(container)) {
		throw new Error('createRoot(...): Target container is not a DOM element');
	}

	let isStrictMode = false;    // 严格模式
	let concurrentUpdatesByDefaultOverride = false;    // 设置更新模式
	let identifierPrefix = '';    //  前缀
	let onRecoverableError = defaultOnRecoverableError;  // 可恢复的错误处理方法
	let transitionCallbacks = null;    // 过度回调

	if(options !== null && options !== undefined) {
		/** 设置严格模式 */
		if(options.unstable_strictMode === true) {
			isStrictMode = true;
		}

		/** 设置 ConcurrentUpdatesByDefaultMode 为 true  */ 
		if(
			allowConcurrentByDefault &&
			options.unstable_concurrentUpdatesByDefault === true
		) {
			concurrentUpdatesByDefaultOverride = true;
		}

		/** 设置前缀 */
		if(options.identifierPrefix !== undefined) {
			identifierPrefix = options..identifierPrefix;
		}

		/** 设置可恢复的错误处理回调 */
		if(options.onRecoverableError !== undefined) {
			onRecoverableError = options.onRecoverableError;
		}

		/** 设置过渡回调 */
		if(options.unstable_transitionCallbacks !== undefined) {
			transitionCallbacks = options.unstable_transitionCallbacks;
		}
	}

	/** 创建 FiberRoot */
	const root = createContainer(
		container,
		ConcurrentRoot,
		null,
		isStrictMode,
		concurrentUpdatesByDefaultOverride,
		identifierPrefix,
		onRecoverableError,
		transitionCallbacks
	);

	/** 将 FiberRoot 挂载到 DOM 节点上 */
	markContainerAsRoot(root.current, container);

	/** 初始化 Dispatcher */
	if(enableFloat) {
		Dispatcher.current = ReactDOMClientDispatcher;
	}

	/** 获取根元素节点 */
	const rootContainerElement = container.nodeType = COMMENT_NODE ? container.parentNode : container;

	/** 监听根元素节点的所有事件 */
	listenToAllSupportedEvents(rootContainerElement);

	/** 返回 ReactDOMRoot */
	return new ReactDOMRoot(root);
}
```

#### 4.1.1 FiberRoot 的创建

##### 4.1.1.1 FiberRootNode

FiberRootNode 是 FiberRoot 的类构造函数，它定义了 FiberRoot 所拥有的属性，这些属性详细的意义将在 Fiber 架构的执行机制彼篇讲解，大家先简单看一下它的代码。

```javascript
function FiberRootNode(
	containerInfo,
	tag,
	hydrate,
	identifierPrefix,
	onRecoverableError
) {
	this.tag = tag;
	this.containerInfo = containerInfo;    // DOM 容器节点
	this.pendingChildren = null;    
	this.current = null;    // Fiber 树
	this.pingCache = null;
	this.finishedWork = null;    
	this.timeoutHandle = noTimeout;
	this.context = null;
	this.pendingContext = null;
	this.callbackNode = null;
	this.callbackPriority = NoLane;
	this.eventTimes = createLaneMap(NoLanes);

	this.pendingLanes = NoLanes;
	this.suspencedLanes = NoLanes;
	this.pingedLanes = NoLanes;
	this.expiredLanes = NoLanes;
	this.mutableReadLanes = NoLanes;

	this.entangledLanes = NoLanes;
	this.hiddenUpdates = createLaneMap(null);

	this.identifierPrefix = identifierPrefix;
	this.onRecoverableError = onRecoverableError;

	if(enableCache) {
		this.pooledCache = null;
		this.pooledCacheLanes = NoLanes;
	}

	if(supportsHydration) {
		this.mutableSourceEagerHydrationData = null;
	}

	if(enableSuspenseCallback) {
		this.hydrationCallbacks = null;
	}

	this.incompleteTransitions = new Map();
	if(enableTransitionTracking) {
		this.transitionCallbacks = null;
		const transitionLanesMap = (this.transitionLanes = []);
		for(let i = 0; i < TotalLanes; i++) {
			pendingUpdatersLaneMap.push(new Set())
		}
	}
}
```

看完了 FiberRootNode 类函数，我们看看 FiberRoot 的创建函数 createContainer 和 createFiberRoot。

##### 4.1.1.2 createContainer

createContainer 函数主要做了两件事：

1. 设置 hydrate 和 initialChildren 两个属性
2. 调用 createFiberRoot 函数创建 FiberRoot 

hydrate 是服务端渲染注水操作的标志，被设置为 false，initialChildren 是初始化的子节点，被设置为 null 。

```javascript
export function createContainer(
	containerInfo,
	tag,
	hydrationCallbacks,
	isStrictMode,
	concurrentUpdatesByDefaultOverride,
	identifierPrefix,
	onRecoverableError,
	transitionCallbacks
) {
	const hydrate = false;    // 服务段渲染相关
	const initialChildren = null;    // 初始子节点

	return createFiberRoot(
		containerInfo,
		tag,
		hydrate,
		initialChildren,
		hydrationCallbacks,
		isStrictMode,
		concurrentUpdatesByDefaultOverride,
		identifierPrefix,
		onRecoverableError,
		transitionCallbacks
	)
}
```          

##### 4.1.1.3 createFiberRoot

createFiberRoot 做了以下几件事：的执行过程中创建了 FiberRoot 和 HostRootFiber 并为 FiberRoot 和 HostRootFiber 做了一些初始化的操作，具体如下：

1. 创建 FiberRoot
2. 为 FiberRoot 设置 hydrationCallbacks 和 transitionCallbacks
3. 创建 HostRootFiber
4. 将 FiberRoot.current 设置为 HostRootFiber
5. 将 HostRootFiber 的 stateNode 设置为 FiberRoot
6. 初始化 HostRootFiber 的更修队列

在 createFiberRoot 的执行过程中创建了 HostRootFiber，并将 FiberRoot 的 current 属性设置为 HostRootFiber、将 HostRootFiber 的 stateNode 属性设置为 FiberRoot 。 现在的 HostRooterFiber 对应的就是未初始化的 Fiber 树，这些内容在 Fiber 架构中会讲到。

``` javascript
export function createFiberRoot(
	containerInfo,
	tag,
	hydrate,
	initialChildren,
	hydrationCallbacks,
	isStrictMode,
	concurrentUpdatesByDefaultOverride,
	identifierPrefix,
	onRecoverableError,
	transitionCallbacks
) {

	/** 创建 FiberRoot */
	const root = new FiberRootNode(
		containerInfo,
		tag,
		hydrate,
		identifierPrefix,
		onRecoverableError
	);

	/** 设置服务端渲染回调 */
	if(enableSuspenseCallback)  {
		root.hydrationCallbacks = hydrationCallbacks;
	}

	/** 设置过渡回调 */
	if(enableTransitionTracing) {
		root.transitionCallbacks = transitionCallbacks;
	}

	/** 创建 HostRootFiber */
	const uninitializedFiber = createHostRootFiber(
		tag,
		isStrictMode,
		concurrentUpdatesByDefaultOverride
	);

	/** 将 HostRootFiber 挂载到 FiberRoot 的 current 属性上 */
	root.current = uninitializedFiber;

	/** 将 HostRootFiber 的 stateNode 设置为 FiberRoot */
	uninitializedFiber.stateNode = root;

	/** 设置 HostRootFiber 的 memoizedState */
	if(enableCache) {
		const initialCache = createCache();
		retainCache(initialCache);
	
		root.pooledCache = initialCache;
		retainCache(initialCache);
		const initialState = {
			element: initialChildren,
			isDehydrated: hydrate,
			cache: initialCache
		};

		uninitializedFiber.memoizedState = initialState;
	} else {
		const initialState:RootState = {
			element: initialChildren,
			isDehydrated: hydrate,
			cache: (null: any)
		};
		uninitializedFiber.memoizedState = initialsTate;
	}

	/** 初始化 HostRootFiber 的更修队列 */
	initializeUpdateQueue(unitializedFiber);

	return root;
}
```               

至此，FiberRoot 就创建完成啦，下面我们将讲解 HostRootFiber 的创建过程。

#### 4.1.2 创建 HostRootFiber 

上面提到过，HostRootFiber 对应着 Fiber 架构中未被初始化过的 Fiber 树，它被挂载到 FiberRoot 的 current 属性上，它的 stateNode 属性也被设置为 FiberRoot 。

createHostRootFiber 是 HostRootFiber 的创建函数，主要做了以下几件事：

 1. 设置 React Fiber 架构的工作模式 （Concurrent 模式、严格模式、ConcurrentUpdatesByDefaultMode 模式）
 2. 设置性能分析的模式
 3. 创建 Fiber

```javascript
export function createHostRootFiber(
	tag,
	isStrictMode,
	concurrentUpdatesByDefaultOverride,
)  {
	let mode;

	/** Concurrent 模式  */
	if ( tag === ConcurrentRoot ) {
		mode = ConcurrentMode;

		/** 严格模式 */
		if(isStrictMode === true || createRootStrictEffectsByDefault) {
			mode |= StrictLegacyMode | StrictEffectsMode;
		}

		if( 
			!enableSyncDefaultUpdates || 
			(allowConcurrentByDefault && concurrentUpdatesByDefaultOverride)
		) {
			/** 设置 ConcurrentUpdatesByDefaultMode  模式 */
			mode |= ConcurrentUpdatesByDefaultMode;
		}
	/** 非 Concurrent 模式 */
	} else {
		mode = NoMode;
	}
     
    /** 性能分析模式 */
	if(enableProfilerTimer && isDevToolsPresent) {
		mode |= ProfileMode;
	}

	return createFiber(HostRoot, null, null, mode);
}
```

经过以上的步骤，FiberRoot 已经被 React 创建完成啦！最后我们来讲解一下 FiberRoot 是怎么被挂载到 DOM 容器节点上的。

#### 4.1.3 FiberRoot 的挂载 

markContainerAsRoot 是过载 FiberRoot 的工作函数，将 Dom 容器节点的 \`\_reactFiber$${ramdomKey}\` 属性设置为 FiberRoot。

源代码如下：

```javascript
cosnt randomKey = Math.ramdom().toString(36).slice(2);

const internalInstanceKey = '_reactFiber$' + randomKey;

/** 在 DOM 节点上设置属性 '_reactFiber' + ramdomKey 为 FiberRoot */
export function markContainerAsRoot(hostInst, node) {
	node[internalInstanceKey] = hostInst;
} 
```               

## 五、结尾

这些就是 React 的初始化的全过程啦！ 欢迎小伙伴们一起讨论~ @V@ ~

最后来则广告 @v@~

> ✨ 布灵布灵！YQY 低代码平台首发啦！
> ---
> 
> #### 🍓 基本功能
> 
> - 通过拖拽自动生成 React 项目代码（包含路由、布局、页面、组件、css样式）。
> - 自动化生成代码仓库。
> - 自动化部署。
> - 快捷访问部署的项目、页面。
> - 通过低代码平台对已生成的项目进行修改。
> - 拉取项目至本地，由开发人员手动开发，推送到远程仓库后自动化部署。
> - 接入不同组件库。
> - 支持接入埋点、监控等前端架构。
> 
> #### 🍓 优点
> 
> - 生成的代码可读性好，包含注释。
> - 可生成不同类型的组件（函数组件、类组件）。
> - 可自动生成项目、布局、页面、路由等。
> - 支持自动创建代码仓库、自动化部署。
> - 支持接入不同组件库。
> - 支持接入埋点、监控等企业级前端架构。
> 
> 😈 如感兴趣，可联系本人：张大可爱宝宝 
> 
> - tel: 16602927079 
> - email: zhangyueqingyun@foxmail.com
> - wechat: abcde-ovo-yz
> 
> 🐼 其他
> ---
> 
> - 🍋 [个人博客](https://zhangyueqingyun.tech)
> - 🍒 [算法测试框架](https://github.com/zhangyueqingyun/algorithm)
> - 🍓 [前端原创资源](https://github.com/zhangyueqingyun/blog-resources)
