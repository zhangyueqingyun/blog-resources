# React Ê∫êÁ†ÅËß£ÊûêÔºöÁ¨¨ÂõõÁ´† ËØ¶Ëß£ Fiber Ê†ëÁöÑÂàùÂßãÂåñËøáÁ®ã 

üòÜ HiÔºåÂ§ßÂÆ∂Â•ΩÔºåÊàëÊòØÂº†Áé•Âçø‰∫ëÔºå‰∏Ä‰∏™Èù¢ÂêëÊú™Êù•ÁºñÁ®ãÁöÑÁ®ãÂ∫èÂëòÔºÅÂáÜÂ§áÂ∞Ü React Ê∫êÁ†ÅËß£ÊûêÂÜôÊàê‰∏ÄÁ≥ªÂàóÊñáÁ´†ÂàÜ‰∫´ÁªôÂ§ßÂÆ∂ÔºåÂ∏åÊúõÂ§ßÂÆ∂ÂñúÊ¨¢~ 

##  ‰∏Ä„ÄÅÂâçË®Ä

‰ªéÁ¨¨‰∏âÁ´†ÂºÄÂßãÔºåÊàë‰ª¨Â∑≤ÁªèËøõÂÖ•‰∫Ü React Ê†∏ÂøÉÈÉ®ÂàÜÔºöFiber Êû∂ÊûÑ„ÄÇËøô‰∏ÄÁ´†Êàë‰ª¨Â∞ÜËÆ≤Ëß£ Fiber Ê†ëÁöÑÂàùÂßãÂåñËøáÁ®ã„ÄÇ

### ‰∫å„ÄÅFiber Ê†ëÁöÑÂàõÂª∫ÊµÅÁ®ã

Âú®Ë∞ÉÁî® ReactDOMRoot.render Ê∏≤ÊüìÂÖÉÁ¥†Ê†ëÁöÑËøáÁ®ã‰∏≠Ôºåreact ‰ºöÂàõÂª∫ Fiber Ê†ë„ÄÇ

```javascript
/** ÂàõÂª∫ÂÖÉÁ¥†Ê†ë */
const element = React.createElement("div", {}, '');

/** ÂàùÂßãÂåñ FiberRootÔºåËøîÂõû ReactDOMRoot */
const root = ReactDOM.createRoot(container);

/** ReactDOMRoot Ê∏≤ÊüìÂÖÉÁ¥†Ê†ë */
root.render(element);
```

ReactDOMRoot.render ÂÜÖÈÉ®ÂèàË∞ÉÁî®‰∫Ü updateContainerÔºåÁ¨¨‰∏ÄÊ¨°Ë∞ÉÁî® updateContainer ‰ºöËøõË°å fiber Ê†ëÁöÑÂàùÂßãÂåñÊìç‰Ωú„ÄÇ


```javascript
ReactDOMRoot.prototype.render = function (children) {
    const root = this._internalRoot;
    if(root === null) {
        throw new Error('Cannot update an unmounted root.');
    }

    updateContainer(children, root, null, null);
}
```
updateContainer ‰∏ªË¶ÅÂÅö‰∫Ü‰ª•‰∏ãÂá†‰ª∂‰∫ãÔºö  

1. Ëé∑Âèñ‰ºòÂÖàÁ∫ß
2. Ëé∑Âèñ context
3. ÂàõÂª∫Êõ¥Êñ∞ÂØπË±°Âπ∂ÂÖ•Èòü
4. ÂºÄÂßãË∞ÉÂ∫¶Ê≠§Ê¨°Êõ¥Êñ∞

‰ª•‰∏ãÊó∂ updateContainer ÁöÑÊ∫êÁ†ÅÔºö

```javascript
export function updateContainer(
    element,
    /** ÁõÆÂâçÊòØ FiberRoot */
    container,
    parentComponent,
    callback
) {
    /** ÁõÆÂâçÊòØ HostRootFiber */
    const current = container.current,
    const eventTime = requestEventTime();

    /** Ëé∑ÂèñËØ•Êõ¥Êñ∞‰∫ã‰ª∂ÂèëÁîüÁöÑ‰ºòÂÖàÁ∫ßÔºåÁ¨¨‰∏ÄÊ¨°Êõ¥Êñ∞Êó∂‰∏∫ DefaultLane */
    const lane = requestUpdateLane(current);

    if(enableSchedulingProfiler) {
        markRenderScheduled(lane);
    }

    /** Ëé∑ÂèñcontextÔºå Á¨¨‰∏ÄÊ¨°Êõ¥Êñ∞Êó∂Ê≤°Êúâ context */
    const context = getContextForSubtree(parentComponent);
    if(container.context === null) {
        container.context = context;
    } else {
        container.pendingContext = context;
    }

    /** ‰∏∫ ReactFiberClassUpdateQueue ÂàõÂª∫‰∏Ä‰∏™Êõ¥Êñ∞ÂØπË±° */
    const update = createUpdate(eventTime, lane);
    update.payload = {element};
    callback = callback === undefined ? null : callback;

    if(callback !== null) {
         update.callback = callback;
    }

    /** Â∞Ü update ÂÖ•Èòü*/
    const root = enqueueUpdate(current, update, lane); // Áî±‰∫é updateContainer  ‰∏çÊ≠¢Ë¢´ ReactDOMRoot.render Ë∞ÉÁî®ÔºåËøò‰∏∫ÊµèËßàÂô®‰∫§‰∫í‰∫ßÁîüÁöÑÊõ¥Êñ∞ÊâÄÁî®ÔºåÊâÄ‰ª•Âú®ÂÖ∂‰∏≠‰ºöÊúâËé∑Âèñ FiberRoot ÁöÑ‰ª£Á†Å 
    
    if(root !== null) {
        /** Ë∞ÉÂ∫¶ Fiber ÁöÑÂàõÂª∫ÂíåÊõ¥Êñ∞ÊµÅÁ®ã */
        scheduleUpdateOnFiber(root, current, lane, eventTime);
        entangleTransitions(root, current, lane);
    }

    return lane;
}
```

scheduleUpdateOnFiber ÂÅö‰∫Ü‰ª•‰∏ãÂá†‰ª∂‰∫ãÔºö

1. Â§ÑÁêÜ FiberRoot ÁöÑ lanes
2. Â§ÑÁêÜÊÄßËÉΩÂàÜÊûêÁõ∏ÂÖ≥ÈÄªËæë
3. Â§ÑÁêÜ transition Áõ∏ÂÖ≥ÈÄªËæë
4. Â§ÑÁêÜ‰ºòÂÖàÁ∫ßÁõ∏ÂÖ≥ÈÄªËæë
5. Ë∞ÉÁî® ensureRootIsScheduled Ë∞ÉÂ∫¶Âπ∂Á°Æ‰øùÊ≠§Ê¨°ÁöÑ FiberRoot ËøõÂÖ•Êõ¥Êñ∞ÔºàÂàùÂßãÂåñÔºâÊµÅÁ®ã„ÄÇ

```javascript
export function scheduleUpdateOnFiber(root, fiber, lane, eventTime) {
    if(workInProgressSuspendedReason == SuspendedOnData && root === workInProgressRoot)  {
        prepareFreshStack(root, NoLanes);
        markRootSuspended(root, workInProgressRootRenderLanes);
    }

    /** ËÆæÁΩÆ FiberRoot ÁöÑ lanesÔºåÂ∞Ü eventTime Âä†ÂÖ• eventTime Êï∞ÁªÑ */
    markRootUpdated(root, lane, eventTime);

    /** ÈùûÁ¨¨‰∏ÄÊ¨°Êõ¥Êñ∞Êó∂ */
    if(
        (executionContext & RenderContext) !== NoLanes && 
        root === workInProgressRoot
    ) {
        workInProgressRootRenderPhaseUpdatedLanes = mergeLanes(
            workInProgressRootRenderPhaseUpdatedLanes,
            lane,
        );
    } else {
        if(enableUpdaterTracking) {
            if(isDevToolsPresent) {
                addFiberToLanesMap(root, fiber, lanes);
            }
        }
    
        warnInfUpdatesNotWrappedWithActDEV(fiber);

        /** ÊÄßËÉΩÂàÜÊûêÁõ∏ÂÖ≥ÔºåÊàë‰ª¨‰∏çÁúãÂÆÉ */
        if(enableProfilerTimer && enableProfilerNestedUpdateScheduledHook) {
            if(
                (executionContext & CommitContext) !== NoContext &&
                root === rootCommittingMutationOrLayoutEffects
            )  {
                if(fiber.mode & ProfileMode) {
                    let current = fiber;
                    while(current !== null) {
                        if(current.tag === Profiler) {
                            const {id, onNestedUpdateScheduled} = current.memoizedProps;
                            if(typeof onNestedUpdateScheduled === 'function') {
                                onNestedUpdateScheduled(id);
                            }
                        }
                        current = current.return;
                    }
                }
           }
        }

        /** Â§ÑÁêÜ transition Áõ∏ÂÖ≥ÈÄªËæëÔºåÊàë‰ª¨ÂÖà‰∏çÁúãÂÆÉ */
        if (enableTransitionTracing)  {
            const transition = ReactCurrentBatchConfig.transition;
            if (transition !== null && transition.name !== null)  {
                if(transition.startTime === -1) {
                    transition.startTime = now();
                }

                addTransitionToLanesMap(root, transition, lane);
            }
        }

        /** ÂΩìÂâç FiberRoot ÂíåÂæÖÊõ¥Êñ∞FiberRoot Áõ∏ÂêåÊó∂ */
        if (root === workInProgressRoot) {
            if(
                deferRenderPhaseUpdateToNextBatch || 
                (executionContext & RenderContext) === NoContext
            )
        } {
            workInProgressRootInterleavedUpdatedaLanes = mergeLanes(
                workInProgressRootInterleavedUpdatedLanes,
                lane,
            );
        }

        if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
            markRootSuspended(root, workInProgressRootRenderLanes);
        }
        /** Á°Æ‰øùË∞ÉÂ∫¶ Fiber Root ÁöÑÂàõÂª∫ÂíåÊõ¥Êñ∞ */
        ensureRootIsScheduled(root, eventTime);

        if(
            lane === SyncLane &&
            executionContext === NoContext &&
            (fiber.mode & ConcurrentMode) === NoMode &&
            !(__DEV__ && ReactCurrentActQueue.isBatchingLegacy)
	    ) {
    	    resetRenderTimer();
    	    flushSyncCallbacksOnlyInLegacyMode();
	    }
    }
}
```

ensureRootIsScheduled ‰∏ªË¶ÅÂÅö‰∫Ü‰ª•‰∏ãÂá†‰ª∂‰∫ãÔºö

1. Ëé∑ÂèñÊ≠§Ê¨°Êõ¥Êñ∞ÁöÑlanes
2. Ëé∑ÂèñÊ≠§Ê¨° lane ÁöÑÊúÄÈ´ò‰ºòÂÖàÁ∫ß
3. ÊâßË°åÂπ∂ÂèëÊàñÂêåÊ≠•Á≠âÊ®°Âºè‰πã‰∏ÄÁöÑ‰ªªÂä°„ÄÇÔºàÂπ∂ÂèëÊ®°Âºè‰∏ã‰∏∫ performConcurrentWorkOnRootÔºâ

```javascript
function ensureRootIsScheduled(root, currentTime) {
    const existingCallbackNode = root.callbackNode;

    markStarvedLanesAsExpired(root, currentTime);

    const nextLanes = getNextLanes(
        root,
        root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,
    );

    if(nextLanes === NoLanes) {
        if( existingCallbackNode !== null) {
            cancelCallback(existingCallbackNode);
        }

        root.callbackNode = null;
        root.callbackPriority = NoLane;
        return;
    }

    const newCallbackPriority = getHighestPriorityLane(nextLanes);
    const existingCallbackPriority = root.callbackPriority;

    if (
        existingCallbackPriority === newCallbackPriority &&
        !(
            __DEV__ &&
            ReactCurrentActQueue.current !== null &&
            existingCallbackNode !== fakeActCallbackNode
        )
    ) {
        return;
    }

    if (existingCallbackNode != null) {
        cancelCallback(existingCallbackNode);
    }

    let newCallbackNode;
    if (newCallbackPriority === SyncLane) {
        if(root.tag ===  LegacyRoot) {
            scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root));
        } else {
            scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
        }
        if(supportMicrotasks) {
            scheduleMicrotask(() =>{
                if(
                    (executionContext & (RenderContext | CommitContext)) === NoContext
                ) {
                    flushSyncCallbacks()
                }
            });
        } else {
            scheduleCallback(ImmediateSchedulerPriority, flushSyncCallbacks);
        }
        newCallbackNode = null;
    } else {
        let schedulerPriorityLevel;
        switch (lanesToEventPriority(nextLanes)) {
            case DiscreteEventPriority:
                schedulerPriorityLevel = ImmediateSchedulerPriority;
                break;
            case ContinuousEventPriority:
                schedulerPriorityLevel = UserBlockingSchedulerPriority;
                break;
            case DefaultEventPriority:
                schedulerPriorityLevel = NormalSchedulerPriority;
                break;
            case IdleEventPriority:
                schedulerPriorityLevel = IdleSchedulerPriority;
                break;
            default:
                schedulerPriorityLevel = NormalSchedulerPriority;
                break;
        }

        newCallbackNode = scheduleCallbackNode = scheduleCallback(
            schedulerPriorityLevel,
            /** ÊâßË°å Concurrent Ê®°Âºè‰∏ãÁöÑ Fiber Ê†ëÁöÑÊûÑÂª∫‰ªªÂä°  */
            performConcurrentWorkOnRoot.bind(null, root)
        );
    }
    root.callbackPriority = new CallbackPriority;
    root.callbackNode = newCallbackNode;
}
```

performConcurrentnWorkOnRoot ÂÜÖË∞ÉÁî®‰∫Ü renderRootConcurrent Êù•Ê∏≤Êüì FiberRoot

```javascript
function performConcurrentWorkOnRoot(root, didTimeout) {
    if(enablePriofilerTimer && enableProfilerNestedUpdatePhase) {
        resetNestedUpdateFlag();
    }

    currentEventTime = NoTimestamp;
    currentEventTransitionLane = NoLanes;

    if((executionContext & (RenderContext | CommitContext)) !== NoContext) {
        throw new Error('Should not already be working');
    }

    const originalCallbackNode = root.callbackNode;
    const didFlushPassiveEffects =  flushPassiveEffects();

    if(didFlushPassiveEffects) {
        if(root.callbackNode !== originalCallbackNode) {
            return null;
        }
    } else {

    }

    let lanes = getNextLanes(
        root,
        root === workInProgressRoot Ôºü workInProgressRootRenderLanes : NoLanes,
    );

    if(lanes === NoLanes) {
        return null;
    }

    const exitStatus = shouldTimeSlice 
        /** ConcurrentÊ®°Âºè‰∏ãÊ∏≤Êüì FiberRoot */
        ? renderRootConcurrent(root, lanes)
        : renderRootSync(root, lanes);

    /** ... */

    ensureRootIsScheduled(root, now());
}
```

renderRootConcurrent ÂÅö‰∫Ü‰ª•‰∏ãÂá†‰ª∂‰∫ãÔºö

1. Ë∞ÉÁî® prepareFreshStack ÂàùÂßãÂåñ Fiber Ê†ëÊûÑÂª∫Â∑•‰Ωú‰∏≠ÈúÄË¶ÅÁöÑ‰∏Ä‰∫õÂÖ®Â±ÄÂèòÈáèÔºàworkInProgress„ÄÅworkInProgressRoot Á≠âÔºâ„ÄÇ
2. Âú®‰∏Ä‰∏™Ê∞∏ÁúüÁöÑ do-while Âæ™ÁéØÈáåÊâßË°å workLoopConcurrent Â∑•‰ΩúÂæ™ÁéØ„ÄÇ

```javascript
function renderRootConcurrent(root, lanes) {
  const prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  const prevDispatcher = pushDispatcher();

  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    if (enableUpdaterTracking) {
      if (isDevToolsPresent) {
        const memoizedUpdaters = root.memoizedUpdaters;
        if (memoizedUpdaters.size > 0) {
          restorePendingUpdaters(root, workInProgressRootRenderLanes);
          memoizedUpdaters.clear();
        }

        movePendingFibersToMemoized(root, lanes);
      }
    }

    workInProgressTransitions = getTransitionsForLanes(root, lanes);
    resetRenderTimer();
    /** ÂàùÂßãÂåñÂÖ®Â±ÄÂèòÈáè workInProgress Âíå workInProgressRoot */
    prepareFreshStack(root, lanes);
  }

  if (enableSchedulingProfiler) {
    markRenderStarted(lanes);
  }

  do {
    try {
        /** ÂºÄÂßã Concurrent Ê®°ÂºèÁöÑÂ∑•‰ΩúÂæ™ÁéØ */
        workLoopConcurrent();
      break;
    } catch (thrownValue) {
      handleError(root, thrownValue);
    }
  } while (true);
  resetContextDependencies();

  popDispatcher(prevDispatcher);
  executionContext = prevExecutionContext;

  // Check if the tree has completed.
  if (workInProgress !== null) {
    // Still work remaining.
    if (enableSchedulingProfiler) {
      markRenderYielded();
    }
    return RootInProgress;
  } else {
    // Completed the tree.
    if (enableSchedulingProfiler) {
      markRenderStopped();
    }

    // Set this to null to indicate there's no in-progress render.
    workInProgressRoot = null;
    workInProgressRootRenderLanes = NoLanes;

    // Return the final exit status.
    return workInProgressRootExitStatus;
  }
}
```

prepareFreshStack ‰∏ªË¶ÅÁöÑ‰ªªÂä°Â∞±ÊòØÂàõÂª∫ workInProgress , workInProgress Êó∂ÊâßË°å‰∏ÄÊ¨°Êõ¥Êñ∞‰ªªÂä°ÁöÑÊï∞ÊçÆÂçïÂÖÉ„ÄÇ

```javascript
function prepareFreshStack(root, lanes) {
  root.finishedWork = null;
  root.finishedLanes = NoLanes;

  const timeoutHandle = root.timeoutHandle;
  if (timeoutHandle !== noTimeout) {
    // The root previous suspended and scheduled a timeout to commit a fallback
    // state. Now that we have additional work, cancel the timeout.
    root.timeoutHandle = noTimeout;
    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
    cancelTimeout(timeoutHandle);
  }

  if (workInProgress !== null) {
    let interruptedWork = workInProgress.return;
    while (interruptedWork !== null) {
      const current = interruptedWork.alternate;
      unwindInterruptedWork(
        current,
        interruptedWork,
        workInProgressRootRenderLanes,
      );
      interruptedWork = interruptedWork.return;
    }
  }
  workInProgressRoot = root;
  const rootWorkInProgress = createWorkInProgress(root.current, null);
  workInProgress = rootWorkInProgress;
  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
  workInProgressRootExitStatus = RootInProgress;
  workInProgressRootFatalError = null;
  workInProgressRootSkippedLanes = NoLanes;
  workInProgressRootInterleavedUpdatedLanes = NoLanes;
  workInProgressRootRenderPhaseUpdatedLanes = NoLanes;
  workInProgressRootPingedLanes = NoLanes;
  workInProgressRootConcurrentErrors = null;
  workInProgressRootRecoverableErrors = null;

  enqueueInterleavedUpdates();

  return rootWorkInProgress;
}
```

createWorkInProgress Ë¥üË¥£ÂàõÂª∫ workInProgressÔºà‰πüÊòØ‰∏Ä‰∏™ FiberÔºâÔºåÂπ∂Â∞ÜÂΩìÂâç fiber ÁöÑÊâÄÊúâÂ±ûÊÄßÂÄºÂ§çÂà∂Áªô workInProgress„ÄÇËØ• workInProgress Â∞±Êõø‰ª£ÂΩìÂâç fiber Êàê‰∏∫Ê≠§Ê¨°ÂæÖÂ§ÑÁêÜÁöÑÊï∞ÊçÆÂçïÂÖÉ„ÄÇ

```javascript
export function createWorkInProgress(current: Fiber, pendingProps: any): Fiber {
  let workInProgress = current.alternate;

  /** ÂΩì workInProgress ‰∏çÂ≠òÂú®Êó∂ÂàõÂª∫ workInProgress */
  if (workInProgress === null) {
    workInProgress = createFiber(
      current.tag,
      pendingProps,
      current.key,
      current.mode,
    );
    workInProgress.elementType = current.elementType;
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  
  /** ÂΩì workInProgress Â≠òÂú®Êó∂ÈáçÂ§çÂà©Áî®‰∏ä‰∏ÄÊ¨°ÁöÑ workInPorgress */
  } else {
    workInProgress.pendingProps = pendingProps;
    workInProgress.type = current.type;

    workInProgress.flags = NoFlags;

    workInProgress.subtreeFlags = NoFlags;
    workInProgress.deletions = null;

    if (enableProfilerTimer) {
      workInProgress.actualDuration = 0;
      workInProgress.actualStartTime = -1;
    }
  }

  workInProgress.flags = current.flags & StaticMask;
  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;

  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;

  const currentDependencies = current.dependencies;
  workInProgress.dependencies =
    currentDependencies === null
      ? null
      : {
          lanes: currentDependencies.lanes,
          firstContext: currentDependencies.firstContext,
        };

  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;

  if (enableProfilerTimer) {
    workInProgress.selfBaseDuration = current.selfBaseDuration;
    workInProgress.treeBaseDuration = current.treeBaseDuration;
  }

  return workInProgress;
}
```

workLoopConcurrent ÈÄöËøá while Âæ™ÁéØÊâßË°å‰ªªÂä°„ÄÇ

```javascript
function workLoopConcurrent() {
  while (workInProgress !== null && !shouldYield()) {
    /** ÊâßË°å‰∏Ä‰∏™ÂçïÂÖÉÁöÑÂ∑•‰ΩúÔºåÂç≥Â§ÑÁêÜ‰∏Ä‰∏™ FiberNode ÁöÑ‰ªªÂä° */
    performUnitOfWork(workInProgress);
  }
}
```

performUnitOfWorkÔºö

1. Ë∞ÉÁî® beginWork ÂºÄÂßãÊâßË°å‰ªªÂä°ÔºàÊûÑÂª∫ Fiber Ê†ëÔºâ„ÄÇ
2. ÂÆåÊàê Fiber Ê†ëÁöÑÊûÑÂª∫„ÄÇ

```javascript
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  setCurrentDebugFiberInDEV(unitOfWork);

  let next;
  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {
    startProfilerTimer(unitOfWork);
    /** ÂºÄÂßã‰ªªÂä°ÔºåÂπ∂‰∏îËøîÂõû‰∏ã‰∏Ä‰∏™ÂæÖÂ§ÑÁêÜÁöÑ Fiber */
    next = beginWork(current, unitOfWork, subtreeRenderLanes);
    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
  } else {
    /** ÂºÄÂßã‰ªªÂä°ÔºåÂπ∂‰∏îËøîÂõû‰∏ã‰∏Ä‰∏™ÂæÖÂ§ÑÁêÜÁöÑ Fiber */
    next = beginWork(current, unitOfWork, subtreeRenderLanes);
  }

  resetCurrentDebugFiberInDEV();
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next === null) {
    /** Fiber Ê†ëÊûÑÂª∫ÂÆåÊàê */
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }

  ReactCurrentOwner.current = null;
}
```

beginWork: 

1.  

```javascript
function beginWork(
  current,
  workInProgress,
  renderLanes,
) {
  if (current !== null) {
    const oldProps = current.memoizedProps;
    const newProps = workInProgress.pendingProps;

    if (
      oldProps !== newProps ||
      hasLegacyContextChanged() ||
      // Force a re-render if the implementation changed due to hot reload:
      (__DEV__ ? workInProgress.type !== current.type : false)
    ) {
      // If props or context changed, mark the fiber as having performed work.
      // This may be unset if the props are determined to be equal later (memo).
      didReceiveUpdate = true;
    } else {
      // Neither props nor legacy context changes. Check if there's a pending
      // update or context change.
      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(
        current,
        renderLanes,
      );
      if (
        !hasScheduledUpdateOrContext &&
        // If this is the second pass of an error or suspense boundary, there
        // may not be work scheduled on `current`, so we check for this flag.
        (workInProgress.flags & DidCapture) === NoFlags
      ) {
        // No pending updates or context. Bail out now.
        didReceiveUpdate = false;
        return attemptEarlyBailoutIfNoScheduledUpdate(
          current,
          workInProgress,
          renderLanes,
        );
      }
      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
        // This is a special case that only exists for legacy mode.
        // See https://github.com/facebook/react/pull/19216.
        didReceiveUpdate = true;
      } else {
        // An update was scheduled on this fiber, but there are no new props
        // nor legacy context. Set this to false. If an update queue or context
        // consumer produces a changed value, it will set this to true. Otherwise,
        // the component will assume the children have not changed and bail out.
        didReceiveUpdate = false;
      }
    }
  } else {
    didReceiveUpdate = false;

    if (getIsHydrating() && isForkedChild(workInProgress)) {
      const slotIndex = workInProgress.index;
      const numberOfForks = getForksAtLevel(workInProgress);
      pushTreeId(workInProgress, numberOfForks, slotIndex);
    }
  }

  workInProgress.lanes = NoLanes;

  switch (workInProgress.tag) {
    case FunctionComponent: {
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return updateFunctionComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }
    case ClassComponent: {
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return updateClassComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }
  }

  throw new Error(
    `Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` +
      'React. Please file an issue.',
  );
}
```

```javascript
function updateFunctionComponent(
    current,
    workInProgress,
    Component,
    nextProps,
    renderLanes,
) {
    let context;
    if (!disableLegacyContext) {
        const unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
        context = getMaskedContext(workInProgress, unmaskedContext);
    }

    let nextChildren;
    let hasId;
    prepareToReadContext(workInProgress, renderLanes);
    if (enableSchedulingProfiler) {
      markComponentRenderStarted(workInProgress);
    }
    nextChildren = renderWithHooks(
      current,
      workInProgress,
      Component,
      nextProps,
      context,
      renderLanes,
    );
    hasId = checkDidRenderIdHook();

    if (enableSchedulingProfiler) {
      markComponentRenderStopped();
    }

    if (current !== null && !didReceiveUpdate) {
      bailoutHooks(current, workInProgress, renderLanes);
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }

    if (getIsHydrating() && hasId) {
      pushMaterializedTreeId(workInProgress);
    }

    workInProgress.flags |= PerformedWork;
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
    return workInProgress.child;
}
```

```javascript
export function renderWithHooks(
  current,
  workInProgress,
  Component,
  props,
  secondArg,
  nextRenderLanes,
) {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber = workInProgress;

  workInProgress.memoizedState = null;
  workInProgress.updateQueue = null;
  workInProgress.lanes = NoLanes;

    ReactCurrentDispatcher.current =
      current === null || current.memoizedState === null
        ? HooksDispatcherOnMount
        : HooksDispatcherOnUpdate;

  let children = Component(props, secondArg);

  // Check if there was a render phase update
  if (didScheduleRenderPhaseUpdateDuringThisPass) {
    let numberOfReRenders: number = 0;
    do {
      didScheduleRenderPhaseUpdateDuringThisPass = false;
      localIdCounter = 0;

      if (numberOfReRenders >= RE_RENDER_LIMIT) {
        throw new Error(
          'Too many re-renders. React limits the number of renders to prevent ' +
            'an infinite loop.',
        );
      }

      numberOfReRenders += 1;

      currentHook = null;
      workInProgressHook = null;

      workInProgress.updateQueue = null;

      ReactCurrentDispatcher.current = __DEV__
        ? HooksDispatcherOnRerenderInDEV
        : HooksDispatcherOnRerender;

      children = Component(props, secondArg);
    } while (didScheduleRenderPhaseUpdateDuringThisPass);
  }

  ReactCurrentDispatcher.current = ContextOnlyDispatcher;

  const didRenderTooFewHooks =
    currentHook !== null && currentHook.next !== null;

  renderLanes = NoLanes;
  currentlyRenderingFiber = (null: any);

  currentHook = null;
  workInProgressHook = null;

  didScheduleRenderPhaseUpdate = false;
  if (didRenderTooFewHooks) {
    throw new Error(
      'Rendered fewer hooks than expected. This may be caused by an accidental ' +
        'early return statement.',
    );
  }

  if (enableLazyContextPropagation) {
    if (current !== null) {
      if (!checkIfWorkInProgressReceivedUpdate()) {
        if (
          currentDependencies !== null &&
          checkIfContextChanged(currentDependencies)
        ) {
          markWorkInProgressReceivedUpdate();
        }
      }
    }
  }
  return children;
}
```

```javascript

export function reconcileChildren(
  current,
  workInProgress,
  nextChildren,
  renderLanes,
) {
  if (current === null) {
    workInProgress.child = mountChildFibers(
      workInProgress,
      null,
      nextChildren,
      renderLanes,
    );
  } else {
    workInProgress.child = reconcileChildFibers(
      workInProgress,
      current.child,
      nextChildren,
      renderLanes,
    );
  }
}
```

```javascript
  function reconcileChildFibers(
    returnFiber,
    currentFirstChild,
    newChild,
    lanes,
  ) {
    const isUnkeyedTopLevelFragment =
      typeof newChild === 'object' &&
      newChild !== null &&
      newChild.type === REACT_FRAGMENT_TYPE &&
      newChild.key === null;
    if (isUnkeyedTopLevelFragment) {
      newChild = newChild.props.children;
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return placeSingleChild(
            reconcileSingleElement(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes,
            ),
          );
        case REACT_PORTAL_TYPE:
          return placeSingleChild(
            reconcileSinglePortal(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes,
            ),
          );
        case REACT_LAZY_TYPE:
          const payload = newChild._payload;
          const init = newChild._init;
          return reconcileChildFibers(
            returnFiber,
            currentFirstChild,
            init(payload),
            lanes,
          );
      }

      if (isArray(newChild)) {
        return reconcileChildrenArray(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes,
        );
      }

      if (getIteratorFn(newChild)) {
        return reconcileChildrenIterator(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes,
        );
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    if (
      (typeof newChild === 'string' && newChild !== '') ||
      typeof newChild === 'number'
    ) {
      return placeSingleChild(
        reconcileSingleTextNode(
          returnFiber,
          currentFirstChild,
          '' + newChild,
          lanes,
        ),
      );
    }

    return deleteRemainingChildren(returnFiber, currentFirstChild);
  }
```

```javascript
  function reconcileSingleElement(
    returnFiber,
    currentFirstChild,
    element,
    lanes,
  ): Fiber {
    const key = element.key;
    let child = currentFirstChild;
    while (child !== null) {
      if (child.key === key) {
        const elementType = element.type;
        if (elementType === REACT_FRAGMENT_TYPE) {
          if (child.tag === Fragment) {
            deleteRemainingChildren(returnFiber, child.sibling);
            const existing = useFiber(child, element.props.children);
            existing.return = returnFiber;
            return existing;
          }
        } else {
          if (
            child.elementType === elementType ||
            (__DEV__
              ? isCompatibleFamilyForHotReloading(child, element)
              : false) ||
            (typeof elementType === 'object' &&
              elementType !== null &&
              elementType.$$typeof === REACT_LAZY_TYPE &&
              resolveLazy(elementType) === child.type)
          ) {
            deleteRemainingChildren(returnFiber, child.sibling);
            const existing = useFiber(child, element.props);
            existing.ref = coerceRef(returnFiber, child, element);
            existing.return = returnFiber;
            return existing;
          }
        }
        deleteRemainingChildren(returnFiber, child);
        break;
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    if (element.type === REACT_FRAGMENT_TYPE) {
      const created = createFiberFromFragment(
        element.props.children,
        returnFiber.mode,
        lanes,
        element.key,
      );
      created.return = returnFiber;
      return created;
    } else {
      const created = createFiberFromElement(element, returnFiber.mode, lanes);
      created.ref = coerceRef(returnFiber, currentFirstChild, element);
      created.return = returnFiber;
      return created;
    }
  }
```

```javascript
  function reconcileChildrenArray(
    returnFiber,
    currentFirstChild,
    newChildren,
    lanes,
  ) {
    let resultingFirstChild: Fiber | null = null;
    let previousNewFiber: Fiber | null = null;

    let oldFiber = currentFirstChild;
    let lastPlacedIndex = 0;
    let newIdx = 0;
    let nextOldFiber = null;
    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      const newFiber = updateSlot(
        returnFiber,
        oldFiber,
        newChildren[newIdx],
        lanes,
      );
      if (newFiber === null) {
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        resultingFirstChild = newFiber;
      } else {
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (newIdx === newChildren.length) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      if (getIsHydrating()) {
        const numberOfForks = newIdx;
        pushTreeFork(returnFiber, numberOfForks);
      }
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      for (; newIdx < newChildren.length; newIdx++) {
        const newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
        if (newFiber === null) {
          continue;
        }
        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = newFiber;
        } else {
          previousNewFiber.sibling = newFiber;
        }
        previousNewFiber = newFiber;
      }
      if (getIsHydrating()) {
        const numberOfForks = newIdx;
        pushTreeFork(returnFiber, numberOfForks);
      }
      return resultingFirstChild;
    }

    // Add all children to a key map for quick lookups.
    const existingChildren = mapRemainingChildren(returnFiber, oldFiber);

    // Keep scanning and use the map to restore deleted items as moves.
    for (; newIdx < newChildren.length; newIdx++) {
      const newFiber = updateFromMap(
        existingChildren,
        returnFiber,
        newIdx,
        newChildren[newIdx],
        lanes,
      );
      if (newFiber !== null) {
        if (shouldTrackSideEffects) {
          if (newFiber.alternate !== null) {
            existingChildren.delete(
              newFiber.key === null ? newIdx : newFiber.key,
            );
          }
        }
        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = newFiber;
        } else {
          previousNewFiber.sibling = newFiber;
        }
        previousNewFiber = newFiber;
      }
    }

    if (shouldTrackSideEffects) {
      existingChildren.forEach(child => deleteChild(returnFiber, child));
    }

    if (getIsHydrating()) {
      const numberOfForks = newIdx;
      pushTreeFork(returnFiber, numberOfForks);
    }
    return resultingFirstChild;
  }
```

```javascript
function FiberNode(
  tag,
  pendingProps,
  key,
  mode,
) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.elementType = null;
  this.type = null;
  this.stateNode = null;

  // Fiber
  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;

  this.ref = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;

  this.mode = mode;

  // Effects
  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.deletions = null;

  this.lanes = NoLanes;
  this.childLanes = NoLanes;

  this.alternate = null;

  if (enableProfilerTimer) {
    this.actualDuration = Number.NaN;
    this.actualStartTime = Number.NaN;
    this.selfBaseDuration = Number.NaN;
    this.treeBaseDuration = Number.NaN;

    this.actualDuration = 0;
    this.actualStartTime = -1;
    this.selfBaseDuration = 0;
    this.treeBaseDuration = 0;
  }
}
```
