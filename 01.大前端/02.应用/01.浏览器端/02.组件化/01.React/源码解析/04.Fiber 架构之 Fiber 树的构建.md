# React æºç è§£æžï¼šç¬¬å››ç«  è¯¦è§£ Fiber æ ‘çš„åˆå§‹åŒ–è¿‡ç¨‹ 

ðŸ˜† Hiï¼Œå¤§å®¶å¥½ï¼Œæˆ‘æ˜¯å¼ çŽ¥å¿äº‘ï¼Œä¸€ä¸ªé¢å‘æœªæ¥ç¼–ç¨‹çš„ç¨‹åºå‘˜ï¼å‡†å¤‡å°† React æºç è§£æžå†™æˆä¸€ç³»åˆ—æ–‡ç« åˆ†äº«ç»™å¤§å®¶ï¼Œå¸Œæœ›å¤§å®¶å–œæ¬¢~ 

##  ä¸€ã€å‰è¨€

ä»Žç¬¬ä¸‰ç« å¼€å§‹ï¼Œæˆ‘ä»¬å·²ç»è¿›å…¥äº† React æ ¸å¿ƒéƒ¨åˆ†ï¼šFiber æž¶æž„ã€‚è¿™ä¸€ç« æˆ‘ä»¬å°†è®²è§£ Fiber æ ‘çš„åˆå§‹åŒ–è¿‡ç¨‹ã€‚

### äºŒã€Fiber æ ‘çš„åˆ›å»ºæµç¨‹

åœ¨è°ƒç”¨ ReactDOMRoot.render æ¸²æŸ“å…ƒç´ æ ‘çš„è¿‡ç¨‹ä¸­ï¼Œreact ä¼šåˆ›å»º Fiber æ ‘ã€‚

```javascript
/** åˆ›å»ºå…ƒç´ æ ‘ */
const element = React.createElement("div", {}, '');

/** åˆå§‹åŒ– FiberRootï¼Œè¿”å›ž ReactDOMRoot */
const root = ReactDOM.createRoot(container);

/** ReactDOMRoot æ¸²æŸ“å…ƒç´ æ ‘ */
root.render(element);
```

ReactDOMRoot.render å†…éƒ¨åˆè°ƒç”¨äº† updateContainerï¼Œç¬¬ä¸€æ¬¡è°ƒç”¨ updateContainer ä¼šè¿›è¡Œ fiber æ ‘çš„åˆå§‹åŒ–æ“ä½œã€‚


```javascript
ReactDOMRoot.prototype.render = function (children) {
    const root = this._internalRoot;
    if(root === null) {
        throw new Error('Cannot update an unmounted root.');
    }

    updateContainer(children, root, null, null);
}
```
updateContainer ä¸»è¦åšäº†ä»¥ä¸‹å‡ ä»¶äº‹ï¼š  

1. èŽ·å–ä¼˜å…ˆçº§
2. èŽ·å– context
3. åˆ›å»ºæ›´æ–°å¯¹è±¡å¹¶å…¥é˜Ÿ
4. å¼€å§‹è°ƒåº¦æ­¤æ¬¡æ›´æ–°

ä»¥ä¸‹æ—¶ updateContainer çš„æºç ï¼š

```javascript
export function updateContainer(
    element,
    /** ç›®å‰æ˜¯ FiberRoot */
    container,
    parentComponent,
    callback
) {
    /** ç›®å‰æ˜¯ HostRootFiber */
    const current = container.current,
    const eventTime = requestEventTime();

    /** èŽ·å–è¯¥æ›´æ–°äº‹ä»¶å‘ç”Ÿçš„ä¼˜å…ˆçº§ï¼Œç¬¬ä¸€æ¬¡æ›´æ–°æ—¶ä¸º DefaultLane */
    const lane = requestUpdateLane(current);

    if(enableSchedulingProfiler) {
        markRenderScheduled(lane);
    }

    /** èŽ·å–contextï¼Œ ç¬¬ä¸€æ¬¡æ›´æ–°æ—¶æ²¡æœ‰ context */
    const context = getContextForSubtree(parentComponent);
    if(container.context === null) {
        container.context = context;
    } else {
        container.pendingContext = context;
    }

    /** ä¸º ReactFiberClassUpdateQueue åˆ›å»ºä¸€ä¸ªæ›´æ–°å¯¹è±¡ */
    const update = createUpdate(eventTime, lane);
    update.payload = {element};
    callback = callback === undefined ? null : callback;

    if(callback !== null) {
         update.callback = callback;
    }

    /** å°† update å…¥é˜Ÿ*/
    const root = enqueueUpdate(current, update, lane); // ç”±äºŽ updateContainer  ä¸æ­¢è¢« ReactDOMRoot.render è°ƒç”¨ï¼Œè¿˜ä¸ºæµè§ˆå™¨äº¤äº’äº§ç”Ÿçš„æ›´æ–°æ‰€ç”¨ï¼Œæ‰€ä»¥åœ¨å…¶ä¸­ä¼šæœ‰èŽ·å– FiberRoot çš„ä»£ç  
    
    if(root !== null) {
        /** è°ƒåº¦ Fiber çš„åˆ›å»ºå’Œæ›´æ–°æµç¨‹ */
        scheduleUpdateOnFiber(root, current, lane, eventTime);
        entangleTransitions(root, current, lane);
    }

    return lane;
}
```

scheduleUpdateOnFiber åšäº†ä»¥ä¸‹å‡ ä»¶äº‹ï¼š

1. å¤„ç† FiberRoot çš„ lanes
2. å¤„ç†æ€§èƒ½åˆ†æžç›¸å…³é€»è¾‘
3. å¤„ç† transition ç›¸å…³é€»è¾‘
4. å¤„ç†ä¼˜å…ˆçº§ç›¸å…³é€»è¾‘
5. è°ƒç”¨ ensureRootIsScheduled è°ƒåº¦å¹¶ç¡®ä¿æ­¤æ¬¡çš„ FiberRoot è¿›å…¥æ›´æ–°ï¼ˆåˆå§‹åŒ–ï¼‰æµç¨‹ã€‚

```javascript
export function scheduleUpdateOnFiber(root, fiber, lane, eventTime) {
    if(workInProgressSuspendedReason == SuspendedOnData && root === workInProgressRoot)  {
        prepareFreshStack(root, NoLanes);
        markRootSuspended(root, workInProgressRootRenderLanes);
    }

    /** è®¾ç½® FiberRoot çš„ lanesï¼Œå°† eventTime åŠ å…¥ eventTime æ•°ç»„ */
    markRootUpdated(root, lane, eventTime);

    /** éžç¬¬ä¸€æ¬¡æ›´æ–°æ—¶ */
    if(
        (executionContext & RenderContext) !== NoLanes && 
        root === workInProgressRoot
    ) {
        workInProgressRootRenderPhaseUpdatedLanes = mergeLanes(
            workInProgressRootRenderPhaseUpdatedLanes,
            lane,
        );
    } else {
        if(enableUpdaterTracking) {
            if(isDevToolsPresent) {
                addFiberToLanesMap(root, fiber, lanes);
            }
        }
    
        warnInfUpdatesNotWrappedWithActDEV(fiber);

        /** æ€§èƒ½åˆ†æžç›¸å…³ï¼Œæˆ‘ä»¬ä¸çœ‹å®ƒ */
        if(enableProfilerTimer && enableProfilerNestedUpdateScheduledHook) {
            if(
                (executionContext & CommitContext) !== NoContext &&
                root === rootCommittingMutationOrLayoutEffects
            )  {
                if(fiber.mode & ProfileMode) {
                    let current = fiber;
                    while(current !== null) {
                        if(current.tag === Profiler) {
                            const {id, onNestedUpdateScheduled} = current.memoizedProps;
                            if(typeof onNestedUpdateScheduled === 'function') {
                                onNestedUpdateScheduled(id);
                            }
                        }
                        current = current.return;
                    }
                }
           }
        }

        /** å¤„ç† transition ç›¸å…³é€»è¾‘ï¼Œæˆ‘ä»¬å…ˆä¸çœ‹å®ƒ */
        if (enableTransitionTracing)  {
            const transition = ReactCurrentBatchConfig.transition;
            if (transition !== null && transition.name !== null)  {
                if(transition.startTime === -1) {
                    transition.startTime = now();
                }

                addTransitionToLanesMap(root, transition, lane);
            }
        }

        /** å½“å‰ FiberRoot å’Œå¾…æ›´æ–°FiberRoot ç›¸åŒæ—¶ */
        if (root === workInProgressRoot) {
            if(
                deferRenderPhaseUpdateToNextBatch || 
                (executionContext & RenderContext) === NoContext
            )
        } {
            workInProgressRootInterleavedUpdatedaLanes = mergeLanes(
                workInProgressRootInterleavedUpdatedLanes,
                lane,
            );
        }

        if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
            markRootSuspended(root, workInProgressRootRenderLanes);
        }
        /** ç¡®ä¿è°ƒåº¦ Fiber Root çš„åˆ›å»ºå’Œæ›´æ–° */
        ensureRootIsScheduled(root, eventTime);

        if(
            lane === SyncLane &&
            executionContext === NoContext &&
            (fiber.mode & ConcurrentMode) === NoMode &&
            !(__DEV__ && ReactCurrentActQueue.isBatchingLegacy)
	    ) {
    	    resetRenderTimer();
    	    flushSyncCallbacksOnlyInLegacyMode();
	    }
    }
}
```

ensureRootIsScheduled ä¸»è¦åšäº†ä»¥ä¸‹å‡ ä»¶äº‹ï¼š

1. èŽ·å–æ­¤æ¬¡æ›´æ–°çš„lanes
2. èŽ·å–æ­¤æ¬¡ lane çš„æœ€é«˜ä¼˜å…ˆçº§
3. æ‰§è¡Œå¹¶å‘æˆ–åŒæ­¥ç­‰æ¨¡å¼ä¹‹ä¸€çš„ä»»åŠ¡ã€‚ï¼ˆå¹¶å‘æ¨¡å¼ä¸‹ä¸º performConcurrentWorkOnRootï¼‰

```javascript
function ensureRootIsScheduled(root, currentTime) {
    const existingCallbackNode = root.callbackNode;

    markStarvedLanesAsExpired(root, currentTime);

    const nextLanes = getNextLanes(
        root,
        root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,
    );

    if(nextLanes === NoLanes) {
        if( existingCallbackNode !== null) {
            cancelCallback(existingCallbackNode);
        }

        root.callbackNode = null;
        root.callbackPriority = NoLane;
        return;
    }

    const newCallbackPriority = getHighestPriorityLane(nextLanes);
    const existingCallbackPriority = root.callbackPriority;

    if (
        existingCallbackPriority === newCallbackPriority &&
        !(
            __DEV__ &&
            ReactCurrentActQueue.current !== null &&
            existingCallbackNode !== fakeActCallbackNode
        )
    ) {
        return;
    }

    if (existingCallbackNode != null) {
        cancelCallback(existingCallbackNode);
    }

    let newCallbackNode;
    if (newCallbackPriority === SyncLane) {
        if(root.tag ===  LegacyRoot) {
            scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root));
        } else {
            scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
        }
        if(supportMicrotasks) {
            scheduleMicrotask(() =>{
                if(
                    (executionContext & (RenderContext | CommitContext)) === NoContext
                ) {
                    flushSyncCallbacks()
                }
            });
        } else {
            scheduleCallback(ImmediateSchedulerPriority, flushSyncCallbacks);
        }
        newCallbackNode = null;
    } else {
        let schedulerPriorityLevel;
        switch (lanesToEventPriority(nextLanes)) {
            case DiscreteEventPriority:
                schedulerPriorityLevel = ImmediateSchedulerPriority;
                break;
            case ContinuousEventPriority:
                schedulerPriorityLevel = UserBlockingSchedulerPriority;
                break;
            case DefaultEventPriority:
                schedulerPriorityLevel = NormalSchedulerPriority;
                break;
            case IdleEventPriority:
                schedulerPriorityLevel = IdleSchedulerPriority;
                break;
            default:
                schedulerPriorityLevel = NormalSchedulerPriority;
                break;
        }

        newCallbackNode = scheduleCallbackNode = scheduleCallback(
            schedulerPriorityLevel,
            /** æ‰§è¡Œ Concurrent æ¨¡å¼ä¸‹çš„ Fiber æ ‘çš„æž„å»ºä»»åŠ¡  */
            performConcurrentWorkOnRoot.bind(null, root)
        );
    }
    root.callbackPriority = new CallbackPriority;
    root.callbackNode = newCallbackNode;
}
```

performConcurrentnWorkOnRoot å†…è°ƒç”¨äº† renderRootConcurrent æ¥æ¸²æŸ“ FiberRoot

```javascript
function performConcurrentWorkOnRoot(root, didTimeout) {
    if(enablePriofilerTimer && enableProfilerNestedUpdatePhase) {
        resetNestedUpdateFlag();
    }

    currentEventTime = NoTimestamp;
    currentEventTransitionLane = NoLanes;

    if((executionContext & (RenderContext | CommitContext)) !== NoContext) {
        throw new Error('Should not already be working');
    }

    const originalCallbackNode = root.callbackNode;
    const didFlushPassiveEffects =  flushPassiveEffects();

    if(didFlushPassiveEffects) {
        if(root.callbackNode !== originalCallbackNode) {
            return null;
        }
    } else {

    }

    let lanes = getNextLanes(
        root,
        root === workInProgressRoot ï¼Ÿ workInProgressRootRenderLanes : NoLanes,
    );

    if(lanes === NoLanes) {
        return null;
    }

    const exitStatus = shouldTimeSlice 
        /** Concurrentæ¨¡å¼ä¸‹æ¸²æŸ“ FiberRoot */
        ? renderRootConcurrent(root, lanes)
        : renderRootSync(root, lanes);

    /** ... */

    ensureRootIsScheduled(root, now());
}
```

renderRootConcurrent åšäº†ä»¥ä¸‹å‡ ä»¶äº‹ï¼š

1. è°ƒç”¨ prepareFreshStack åˆå§‹åŒ– Fiber æ ‘æž„å»ºå·¥ä½œä¸­éœ€è¦çš„ä¸€äº›å…¨å±€å˜é‡ï¼ˆworkInProgressã€workInProgressRoot ç­‰ï¼‰ã€‚
2. åœ¨ä¸€ä¸ªæ°¸çœŸçš„ do-while å¾ªçŽ¯é‡Œæ‰§è¡Œ workLoopConcurrent å·¥ä½œå¾ªçŽ¯ã€‚

```javascript
function renderRootConcurrent(root, lanes) {
  const prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  const prevDispatcher = pushDispatcher();

  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    if (enableUpdaterTracking) {
      if (isDevToolsPresent) {
        const memoizedUpdaters = root.memoizedUpdaters;
        if (memoizedUpdaters.size > 0) {
          restorePendingUpdaters(root, workInProgressRootRenderLanes);
          memoizedUpdaters.clear();
        }

        movePendingFibersToMemoized(root, lanes);
      }
    }

    workInProgressTransitions = getTransitionsForLanes(root, lanes);
    resetRenderTimer();
    /** åˆå§‹åŒ–å…¨å±€å˜é‡ workInProgress å’Œ workInProgressRoot */
    prepareFreshStack(root, lanes);
  }

  if (enableSchedulingProfiler) {
    markRenderStarted(lanes);
  }

  do {
    try {
        /** å¼€å§‹ Concurrent æ¨¡å¼çš„å·¥ä½œå¾ªçŽ¯ */
        workLoopConcurrent();
      break;
    } catch (thrownValue) {
      handleError(root, thrownValue);
    }
  } while (true);
  resetContextDependencies();

  popDispatcher(prevDispatcher);
  executionContext = prevExecutionContext;

  // Check if the tree has completed.
  if (workInProgress !== null) {
    // Still work remaining.
    if (enableSchedulingProfiler) {
      markRenderYielded();
    }
    return RootInProgress;
  } else {
    // Completed the tree.
    if (enableSchedulingProfiler) {
      markRenderStopped();
    }

    // Set this to null to indicate there's no in-progress render.
    workInProgressRoot = null;
    workInProgressRootRenderLanes = NoLanes;

    // Return the final exit status.
    return workInProgressRootExitStatus;
  }
}
```

prepareFreshStack ä¸»è¦çš„ä»»åŠ¡å°±æ˜¯åˆ›å»º workInProgress , workInProgress æ—¶æ‰§è¡Œä¸€æ¬¡æ›´æ–°ä»»åŠ¡çš„æ•°æ®å•å…ƒã€‚

```javascript
function prepareFreshStack(root, lanes) {
  root.finishedWork = null;
  root.finishedLanes = NoLanes;

  const timeoutHandle = root.timeoutHandle;
  if (timeoutHandle !== noTimeout) {
    // The root previous suspended and scheduled a timeout to commit a fallback
    // state. Now that we have additional work, cancel the timeout.
    root.timeoutHandle = noTimeout;
    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
    cancelTimeout(timeoutHandle);
  }

  if (workInProgress !== null) {
    let interruptedWork = workInProgress.return;
    while (interruptedWork !== null) {
      const current = interruptedWork.alternate;
      unwindInterruptedWork(
        current,
        interruptedWork,
        workInProgressRootRenderLanes,
      );
      interruptedWork = interruptedWork.return;
    }
  }
  workInProgressRoot = root;
  const rootWorkInProgress = createWorkInProgress(root.current, null);
  workInProgress = rootWorkInProgress;
  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
  workInProgressRootExitStatus = RootInProgress;
  workInProgressRootFatalError = null;
  workInProgressRootSkippedLanes = NoLanes;
  workInProgressRootInterleavedUpdatedLanes = NoLanes;
  workInProgressRootRenderPhaseUpdatedLanes = NoLanes;
  workInProgressRootPingedLanes = NoLanes;
  workInProgressRootConcurrentErrors = null;
  workInProgressRootRecoverableErrors = null;

  enqueueInterleavedUpdates();

  return rootWorkInProgress;
}
```

createWorkInProgress è´Ÿè´£åˆ›å»º workInProgressï¼ˆä¹Ÿæ˜¯ä¸€ä¸ª Fiberï¼‰ï¼Œå¹¶å°†å½“å‰ fiber çš„æ‰€æœ‰å±žæ€§å€¼å¤åˆ¶ç»™ workInProgressã€‚è¯¥ workInProgress å°±æ›¿ä»£å½“å‰ fiber æˆä¸ºæ­¤æ¬¡å¾…å¤„ç†çš„æ•°æ®å•å…ƒã€‚

```javascript
export function createWorkInProgress(current: Fiber, pendingProps: any): Fiber {
  let workInProgress = current.alternate;

  /** å½“ workInProgress ä¸å­˜åœ¨æ—¶åˆ›å»º workInProgress */
  if (workInProgress === null) {
    workInProgress = createFiber(
      current.tag,
      pendingProps,
      current.key,
      current.mode,
    );
    workInProgress.elementType = current.elementType;
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  
  /** å½“ workInProgress å­˜åœ¨æ—¶é‡å¤åˆ©ç”¨ä¸Šä¸€æ¬¡çš„ workInPorgress */
  } else {
    workInProgress.pendingProps = pendingProps;
    workInProgress.type = current.type;

    workInProgress.flags = NoFlags;

    workInProgress.subtreeFlags = NoFlags;
    workInProgress.deletions = null;

    if (enableProfilerTimer) {
      workInProgress.actualDuration = 0;
      workInProgress.actualStartTime = -1;
    }
  }

  workInProgress.flags = current.flags & StaticMask;
  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;

  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;

  const currentDependencies = current.dependencies;
  workInProgress.dependencies =
    currentDependencies === null
      ? null
      : {
          lanes: currentDependencies.lanes,
          firstContext: currentDependencies.firstContext,
        };

  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;

  if (enableProfilerTimer) {
    workInProgress.selfBaseDuration = current.selfBaseDuration;
    workInProgress.treeBaseDuration = current.treeBaseDuration;
  }

  return workInProgress;
}
```

workLoopConcurrent é€šè¿‡ while å¾ªçŽ¯æ‰§è¡Œä»»åŠ¡ã€‚

```javascript
function workLoopConcurrent() {
  while (workInProgress !== null && !shouldYield()) {
    /** æ‰§è¡Œä¸€ä¸ªå•å…ƒçš„å·¥ä½œï¼Œå³å¤„ç†ä¸€ä¸ª FiberNode çš„ä»»åŠ¡ */
    performUnitOfWork(workInProgress);
  }
}
```

performUnitOfWorkï¼š

1. è°ƒç”¨ beginWork å¼€å§‹æ‰§è¡Œä»»åŠ¡ï¼ˆæž„å»º Fiber æ ‘ï¼‰ã€‚
2. å®Œæˆ Fiber æ ‘çš„æž„å»ºã€‚

```javascript
function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  setCurrentDebugFiberInDEV(unitOfWork);

  let next;
  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {
    startProfilerTimer(unitOfWork);
    /** å¼€å§‹ä»»åŠ¡ï¼Œå¹¶ä¸”è¿”å›žä¸‹ä¸€ä¸ªå¾…å¤„ç†çš„ Fiber */
    next = beginWork(current, unitOfWork, subtreeRenderLanes);
    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
  } else {
    /** å¼€å§‹ä»»åŠ¡ï¼Œå¹¶ä¸”è¿”å›žä¸‹ä¸€ä¸ªå¾…å¤„ç†çš„ Fiber */
    next = beginWork(current, unitOfWork, subtreeRenderLanes);
  }

  resetCurrentDebugFiberInDEV();
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next === null) {
    /** Fiber æ ‘æž„å»ºå®Œæˆ */
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }

  ReactCurrentOwner.current = null;
}
```

beginWork: 

1.  

```javascript
function beginWork(
  current,
  workInProgress,
  renderLanes,
) {
  if (current !== null) {
    const oldProps = current.memoizedProps;
    const newProps = workInProgress.pendingProps;

    if (
      oldProps !== newProps ||
      hasLegacyContextChanged() ||
      // Force a re-render if the implementation changed due to hot reload:
      (__DEV__ ? workInProgress.type !== current.type : false)
    ) {
      // If props or context changed, mark the fiber as having performed work.
      // This may be unset if the props are determined to be equal later (memo).
      didReceiveUpdate = true;
    } else {
      // Neither props nor legacy context changes. Check if there's a pending
      // update or context change.
      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(
        current,
        renderLanes,
      );
      if (
        !hasScheduledUpdateOrContext &&
        // If this is the second pass of an error or suspense boundary, there
        // may not be work scheduled on `current`, so we check for this flag.
        (workInProgress.flags & DidCapture) === NoFlags
      ) {
        // No pending updates or context. Bail out now.
        didReceiveUpdate = false;
        return attemptEarlyBailoutIfNoScheduledUpdate(
          current,
          workInProgress,
          renderLanes,
        );
      }
      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
        // This is a special case that only exists for legacy mode.
        // See https://github.com/facebook/react/pull/19216.
        didReceiveUpdate = true;
      } else {
        // An update was scheduled on this fiber, but there are no new props
        // nor legacy context. Set this to false. If an update queue or context
        // consumer produces a changed value, it will set this to true. Otherwise,
        // the component will assume the children have not changed and bail out.
        didReceiveUpdate = false;
      }
    }
  } else {
    didReceiveUpdate = false;

    if (getIsHydrating() && isForkedChild(workInProgress)) {
      const slotIndex = workInProgress.index;
      const numberOfForks = getForksAtLevel(workInProgress);
      pushTreeId(workInProgress, numberOfForks, slotIndex);
    }
  }

  workInProgress.lanes = NoLanes;

  switch (workInProgress.tag) {
    case FunctionComponent: {
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return updateFunctionComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }
    case ClassComponent: {
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return updateClassComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }
  }

  throw new Error(
    `Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` +
      'React. Please file an issue.',
  );
}
```

```javascript
function updateFunctionComponent(
    current,
    workInProgress,
    Component,
    nextProps,
    renderLanes,
) {
    let context;
    if (!disableLegacyContext) {
        const unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
        context = getMaskedContext(workInProgress, unmaskedContext);
    }

    let nextChildren;
    let hasId;
    prepareToReadContext(workInProgress, renderLanes);
    if (enableSchedulingProfiler) {
      markComponentRenderStarted(workInProgress);
    }
    nextChildren = renderWithHooks(
      current,
      workInProgress,
      Component,
      nextProps,
      context,
      renderLanes,
    );
    hasId = checkDidRenderIdHook();

    if (enableSchedulingProfiler) {
      markComponentRenderStopped();
    }

    if (current !== null && !didReceiveUpdate) {
      bailoutHooks(current, workInProgress, renderLanes);
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }

    if (getIsHydrating() && hasId) {
      pushMaterializedTreeId(workInProgress);
    }

    workInProgress.flags |= PerformedWork;
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
    return workInProgress.child;
}
```

```javascript
export function renderWithHooks(
  current,
  workInProgress,
  Component,
  props,
  secondArg,
  nextRenderLanes,
) {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber = workInProgress;

  workInProgress.memoizedState = null;
  workInProgress.updateQueue = null;
  workInProgress.lanes = NoLanes;

    ReactCurrentDispatcher.current =
      current === null || current.memoizedState === null
        ? HooksDispatcherOnMount
        : HooksDispatcherOnUpdate;

  let children = Component(props, secondArg);

  // Check if there was a render phase update
  if (didScheduleRenderPhaseUpdateDuringThisPass) {
    let numberOfReRenders: number = 0;
    do {
      didScheduleRenderPhaseUpdateDuringThisPass = false;
      localIdCounter = 0;

      if (numberOfReRenders >= RE_RENDER_LIMIT) {
        throw new Error(
          'Too many re-renders. React limits the number of renders to prevent ' +
            'an infinite loop.',
        );
      }

      numberOfReRenders += 1;

      currentHook = null;
      workInProgressHook = null;

      workInProgress.updateQueue = null;

      ReactCurrentDispatcher.current = __DEV__
        ? HooksDispatcherOnRerenderInDEV
        : HooksDispatcherOnRerender;

      children = Component(props, secondArg);
    } while (didScheduleRenderPhaseUpdateDuringThisPass);
  }

  ReactCurrentDispatcher.current = ContextOnlyDispatcher;

  const didRenderTooFewHooks =
    currentHook !== null && currentHook.next !== null;

  renderLanes = NoLanes;
  currentlyRenderingFiber = (null: any);

  currentHook = null;
  workInProgressHook = null;

  didScheduleRenderPhaseUpdate = false;
  if (didRenderTooFewHooks) {
    throw new Error(
      'Rendered fewer hooks than expected. This may be caused by an accidental ' +
        'early return statement.',
    );
  }

  if (enableLazyContextPropagation) {
    if (current !== null) {
      if (!checkIfWorkInProgressReceivedUpdate()) {
        if (
          currentDependencies !== null &&
          checkIfContextChanged(currentDependencies)
        ) {
          markWorkInProgressReceivedUpdate();
        }
      }
    }
  }
  return children;
}
```

```javascript

export function reconcileChildren(
  current,
  workInProgress,
  nextChildren,
  renderLanes,
) {
  if (current === null) {
    workInProgress.child = mountChildFibers(
      workInProgress,
      null,
      nextChildren,
      renderLanes,
    );
  } else {
    workInProgress.child = reconcileChildFibers(
      workInProgress,
      current.child,
      nextChildren,
      renderLanes,
    );
  }
}
```

```javascript
  function reconcileChildFibers(
    returnFiber,
    currentFirstChild,
    newChild,
    lanes,
  ) {
    const isUnkeyedTopLevelFragment =
      typeof newChild === 'object' &&
      newChild !== null &&
      newChild.type === REACT_FRAGMENT_TYPE &&
      newChild.key === null;
    if (isUnkeyedTopLevelFragment) {
      newChild = newChild.props.children;
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return placeSingleChild(
            reconcileSingleElement(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes,
            ),
          );
        case REACT_PORTAL_TYPE:
          return placeSingleChild(
            reconcileSinglePortal(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes,
            ),
          );
        case REACT_LAZY_TYPE:
          const payload = newChild._payload;
          const init = newChild._init;
          return reconcileChildFibers(
            returnFiber,
            currentFirstChild,
            init(payload),
            lanes,
          );
      }

      if (isArray(newChild)) {
        return reconcileChildrenArray(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes,
        );
      }

      if (getIteratorFn(newChild)) {
        return reconcileChildrenIterator(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes,
        );
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    if (
      (typeof newChild === 'string' && newChild !== '') ||
      typeof newChild === 'number'
    ) {
      return placeSingleChild(
        reconcileSingleTextNode(
          returnFiber,
          currentFirstChild,
          '' + newChild,
          lanes,
        ),
      );
    }

    return deleteRemainingChildren(returnFiber, currentFirstChild);
  }
```

```javascript
  function reconcileSingleElement(
    returnFiber,
    currentFirstChild,
    element,
    lanes,
  ): Fiber {
    const key = element.key;
    let child = currentFirstChild;
    while (child !== null) {
      if (child.key === key) {
        const elementType = element.type;
        if (elementType === REACT_FRAGMENT_TYPE) {
          if (child.tag === Fragment) {
            deleteRemainingChildren(returnFiber, child.sibling);
            const existing = useFiber(child, element.props.children);
            existing.return = returnFiber;
            return existing;
          }
        } else {
          if (
            child.elementType === elementType ||
            (__DEV__
              ? isCompatibleFamilyForHotReloading(child, element)
              : false) ||
            (typeof elementType === 'object' &&
              elementType !== null &&
              elementType.$$typeof === REACT_LAZY_TYPE &&
              resolveLazy(elementType) === child.type)
          ) {
            deleteRemainingChildren(returnFiber, child.sibling);
            const existing = useFiber(child, element.props);
            existing.ref = coerceRef(returnFiber, child, element);
            existing.return = returnFiber;
            return existing;
          }
        }
        deleteRemainingChildren(returnFiber, child);
        break;
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    if (element.type === REACT_FRAGMENT_TYPE) {
      const created = createFiberFromFragment(
        element.props.children,
        returnFiber.mode,
        lanes,
        element.key,
      );
      created.return = returnFiber;
      return created;
    } else {
      const created = createFiberFromElement(element, returnFiber.mode, lanes);
      created.ref = coerceRef(returnFiber, currentFirstChild, element);
      created.return = returnFiber;
      return created;
    }
  }
```

```javascript
  function reconcileChildrenArray(
    returnFiber,
    currentFirstChild,
    newChildren,
    lanes,
  ) {
    let resultingFirstChild: Fiber | null = null;
    let previousNewFiber: Fiber | null = null;

    let oldFiber = currentFirstChild;
    let lastPlacedIndex = 0;
    let newIdx = 0;
    let nextOldFiber = null;
    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      const newFiber = updateSlot(
        returnFiber,
        oldFiber,
        newChildren[newIdx],
        lanes,
      );
      if (newFiber === null) {
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        resultingFirstChild = newFiber;
      } else {
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (newIdx === newChildren.length) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      if (getIsHydrating()) {
        const numberOfForks = newIdx;
        pushTreeFork(returnFiber, numberOfForks);
      }
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      for (; newIdx < newChildren.length; newIdx++) {
        const newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
        if (newFiber === null) {
          continue;
        }
        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = newFiber;
        } else {
          previousNewFiber.sibling = newFiber;
        }
        previousNewFiber = newFiber;
      }
      if (getIsHydrating()) {
        const numberOfForks = newIdx;
        pushTreeFork(returnFiber, numberOfForks);
      }
      return resultingFirstChild;
    }

    // Add all children to a key map for quick lookups.
    const existingChildren = mapRemainingChildren(returnFiber, oldFiber);

    // Keep scanning and use the map to restore deleted items as moves.
    for (; newIdx < newChildren.length; newIdx++) {
      const newFiber = updateFromMap(
        existingChildren,
        returnFiber,
        newIdx,
        newChildren[newIdx],
        lanes,
      );
      if (newFiber !== null) {
        if (shouldTrackSideEffects) {
          if (newFiber.alternate !== null) {
            existingChildren.delete(
              newFiber.key === null ? newIdx : newFiber.key,
            );
          }
        }
        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = newFiber;
        } else {
          previousNewFiber.sibling = newFiber;
        }
        previousNewFiber = newFiber;
      }
    }

    if (shouldTrackSideEffects) {
      existingChildren.forEach(child => deleteChild(returnFiber, child));
    }

    if (getIsHydrating()) {
      const numberOfForks = newIdx;
      pushTreeFork(returnFiber, numberOfForks);
    }
    return resultingFirstChild;
  }
```

```javascript
function FiberNode(
  tag,
  pendingProps,
  key,
  mode,
) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.elementType = null;
  this.type = null;
  this.stateNode = null;

  // Fiber
  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;

  this.ref = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;

  this.mode = mode;

  // Effects
  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.deletions = null;

  this.lanes = NoLanes;
  this.childLanes = NoLanes;

  this.alternate = null;

  if (enableProfilerTimer) {
    this.actualDuration = Number.NaN;
    this.actualStartTime = Number.NaN;
    this.selfBaseDuration = Number.NaN;
    this.treeBaseDuration = Number.NaN;

    this.actualDuration = 0;
    this.actualStartTime = -1;
    this.selfBaseDuration = 0;
    this.treeBaseDuration = 0;
  }
}
```
