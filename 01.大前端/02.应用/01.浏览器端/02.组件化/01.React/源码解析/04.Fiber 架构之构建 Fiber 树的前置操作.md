# ç¬¬å››ç«  æ„å»º Fiber æ ‘çš„å‰ç½®æ“ä½œ

ğŸ˜† Hiï¼Œå¤§å®¶å¥½ï¼Œæˆ‘æ˜¯å¼ ç¥å¿äº‘ï¼Œä¸€ä¸ªé¢å‘æœªæ¥ç¼–ç¨‹çš„ç¨‹åºå‘˜ï¼å‡†å¤‡å°† React æºç è§£æå†™æˆä¸€ç³»åˆ—æ–‡ç« åˆ†äº«ç»™å¤§å®¶ï¼Œå¸Œæœ›å¤§å®¶å–œæ¬¢~ 

##  ä¸€ã€å‰è¨€

ä»ç¬¬ä¸‰ç« å¼€å§‹ï¼Œæˆ‘ä»¬å·²ç»è¿›å…¥äº† React æ ¸å¿ƒéƒ¨åˆ†ï¼šFiber æ¶æ„ã€‚è¿™ä¸€ç« æˆ‘ä»¬å°†è®²è§£æ„å»º Fiber æ ‘çš„å‰ç½®æ“ä½œã€‚

```javascript
/** åˆ›å»ºå…ƒç´ æ ‘ */
const element = React.createElement("div", {}, '');

/** åˆå§‹åŒ– FiberRootï¼Œè¿”å› ReactDOMRoot */
const root = ReactDOM.createRoot(container);

/** ReactDOMRoot æ¸²æŸ“å…ƒç´ æ ‘ */
root.render(element);
```

ReactDOMRoot.render ä¼šæ¸²æŸ“æˆ‘ä»¬å®šä¹‰å¥½çš„å…ƒç´ æ ‘ï¼Œåœ¨æ¸²æŸ“çš„è¿‡ç¨‹ä¸­ï¼Œreact ä¼šåˆå§‹åŒ–æˆ–æ›´æ–°å…ƒç´ æ ‘çš„å†…éƒ¨è¡¨ç¤º - Fiber æ ‘ã€‚

```javascript
ReactDOMRoot.prototype.render = function (children) {
    const root = this._internalRoot;
    if(root === null) {
        throw new Error('Cannot update an unmounted root.');
    }
    /** åˆå§‹åŒ–æˆ–æ›´æ–° FiberRoot */
    updateContainer(children, root, null, null);
}
```

ReactDOMRoot.render è°ƒç”¨ updateContainer å‡½æ•°å®Œæˆå¯¹è¯¥å®¹å™¨èŠ‚ç‚¹çš„æ›´æ–°ã€‚

å½“æœªåˆå§‹åŒ–è¿‡ Fiber æ ‘æ—¶, updateContainer ä¼šè¿›è¡Œ fiber æ ‘çš„åˆ›å»ºå·¥ä½œï¼›å½“æ›´æ–°äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œ updateContainer ä¼šè¿›è¡Œ fiber æ ‘çš„æ›´æ–°æ“ä½œã€‚

ä¸‹é¢æˆ‘ä»¬å°†è¯¦ç»†çœ‹ä¸€ä¸‹ Fiber æ ‘çš„åˆå§‹åŒ–ã€‚

## äºŒã€Fiber æ ‘çš„åˆå§‹åŒ–


#### 2.1 åˆ›å»º fiber æ ‘å‰çš„å‡†å¤‡å·¥ä½œ

åˆ›å»º fiber æ ‘ä¹‹å‰ï¼Œreact åšäº†æ¯”è¾ƒå¤šçš„å‡†å¤‡å·¥ä½œï¼Œå…¶ä¸­æ¶‰åŠäº† updateContainerã€scheduleUpdateOnFiberã€ensureRootIsScheduledã€performConcurrentWorkOnRootã€renderRootConcurrentã€prepareFreshStackã€createWorkInProgress è¿™äº›å‡½æ•°çš„è°ƒç”¨ã€‚

å…¶ä¸­ updateContainerã€scheduleUpdateOnFiberã€ensureRootIsScheduledã€performConcurrentWorkOnRootã€renderRootConcurrent å¤„ç†äº†æ›´æ–°çš„ä¼˜å…ˆçº§ã€laneã€contextç­‰æ•°æ®ã€‚prepareFreshStackã€createWorkInProgress åˆ›å»ºäº†æ¯ä¸€ä¸ªä»»åŠ¡æ‰§è¡Œçš„æœ€å°æ•°æ®å•å…ƒï¼šworkInProgressã€‚

æ¥ä¸‹æ¥æˆ‘ä»¬çœ‹ä¸€ä¸‹è¿™äº›å‡†å¤‡å·¥ä½œ

##### 2.1.1 updateContainer

updateContainer ä¸»è¦åšäº†ä»¥ä¸‹å‡ ä»¶äº‹ï¼š  

1. è·å–è¯¥æ¬¡æ›´æ–°çš„ä¼˜å…ˆçº§ï¼ˆåˆå§‹åŒ–æ—¶ä¸º DefaultLaneï¼‰ã€‚
2. å¤„ç† context ã€‚
3. åˆ›å»ºæ›´æ–°å¯¹è±¡å¹¶åŠ å…¥æ›´æ–°é˜Ÿåˆ—ã€‚
4. è°ƒç”¨ scheduleUpdateOnFiber å¼€å§‹è°ƒåº¦æ­¤æ¬¡æ›´æ–°ã€‚

```javascript
export function updateContainer(
    element,
    /** ç›®å‰æ˜¯ FiberRoot */
    container,
    parentComponent,
    callback
) {
    /** ç›®å‰æ˜¯ HostRootFiber */
    const current = container.current,
    const eventTime = requestEventTime();

    /** è·å–è¯¥æ›´æ–°äº‹ä»¶å‘ç”Ÿçš„ä¼˜å…ˆçº§ï¼Œç¬¬ä¸€æ¬¡æ›´æ–°æ—¶ä¸º DefaultLane */
    const lane = requestUpdateLane(current);

    if(enableSchedulingProfiler) {
        markRenderScheduled(lane);
    }

    /** è·å–contextï¼Œ ç¬¬ä¸€æ¬¡æ›´æ–°æ—¶æ²¡æœ‰ context */
    const context = getContextForSubtree(parentComponent);
    if(container.context === null) {
        container.context = context;
    } else {
        container.pendingContext = context;
    }

    /** ä¸º ReactFiberClassUpdateQueue åˆ›å»ºä¸€ä¸ªæ›´æ–°å¯¹è±¡ */
    const update = createUpdate(eventTime, lane);
    update.payload = { element };
    callback = callback === undefined ? null : callback;

    if(callback !== null) {
         update.callback = callback;
    }

    /** å°† update å…¥é˜Ÿ*/
    const root = enqueueUpdate(current, update, lane); // ç”±äº updateContainer  ä¸æ­¢è¢« ReactDOMRoot.render è°ƒç”¨ï¼Œè¿˜ä¸ºæµè§ˆå™¨äº¤äº’äº§ç”Ÿçš„æ›´æ–°æ‰€ç”¨ï¼Œæ‰€ä»¥åœ¨å…¶ä¸­ä¼šæœ‰è·å– FiberRoot çš„ä»£ç  
    
    if(root !== null) {
        /** è°ƒåº¦ Fiber çš„åˆ›å»ºå’Œæ›´æ–°æµç¨‹ */
        scheduleUpdateOnFiber(root, current, lane, eventTime);
        entangleTransitions(root, current, lane);
    }

    return lane;
}
```

scheduleUpdateOnFiber è´Ÿè´£å¼€å§‹è°ƒåº¦æ­¤æ¬¡æ›´æ–°ï¼ˆåˆå§‹åŒ–ï¼‰ã€‚

#### 2.1.2 scheduleUpdateOnFiber

scheduleUpdateOnFiber åšäº†ä»¥ä¸‹å‡ ä»¶äº‹ï¼š

1. å¤„ç† FiberRoot çš„ lanesã€‚
2. å¤„ç†æ€§èƒ½åˆ†æç›¸å…³é€»è¾‘
3. å¤„ç† transition ç›¸å…³é€»è¾‘
4. å¤„ç†ä¼˜å…ˆçº§ç›¸å…³é€»è¾‘
5. è°ƒç”¨ ensureRootIsScheduled è°ƒåº¦å¹¶ç¡®ä¿æ­¤æ¬¡çš„ FiberRoot è¿›å…¥æ›´æ–°ï¼ˆåˆå§‹åŒ–ï¼‰æµç¨‹ã€‚

```javascript
export function scheduleUpdateOnFiber(root, fiber, lane, eventTime) {
    if(workInProgressSuspendedReason == SuspendedOnData && root === workInProgressRoot)  {
        prepareFreshStack(root, NoLanes);
        markRootSuspended(root, workInProgressRootRenderLanes);
    }

    /** è®¾ç½® FiberRoot çš„ lanesï¼Œå°† eventTime åŠ å…¥ eventTime æ•°ç»„ */
    markRootUpdated(root, lane, eventTime);

    /** éç¬¬ä¸€æ¬¡æ›´æ–°æ—¶ */
    if(
        (executionContext & RenderContext) !== NoLanes && 
        root === workInProgressRoot
    ) {
        workInProgressRootRenderPhaseUpdatedLanes = mergeLanes(
            workInProgressRootRenderPhaseUpdatedLanes,
            lane,
        );
    } else {
        if(enableUpdaterTracking) {
            if(isDevToolsPresent) {
                addFiberToLanesMap(root, fiber, lanes);
            }
        }
    
        warnInfUpdatesNotWrappedWithActDEV(fiber);

        /** æ€§èƒ½åˆ†æç›¸å…³ï¼Œæˆ‘ä»¬ä¸çœ‹å®ƒ */
        if(enableProfilerTimer && enableProfilerNestedUpdateScheduledHook) {
            if(
                (executionContext & CommitContext) !== NoContext &&
                root === rootCommittingMutationOrLayoutEffects
            )  {
                if(fiber.mode & ProfileMode) {
                    let current = fiber;
                    while(current !== null) {
                        if(current.tag === Profiler) {
                            const {id, onNestedUpdateScheduled} = current.memoizedProps;
                            if(typeof onNestedUpdateScheduled === 'function') {
                                onNestedUpdateScheduled(id);
                            }
                        }
                        current = current.return;
                    }
                }
           }
        }

        /** å¤„ç† transition ç›¸å…³é€»è¾‘ï¼Œæˆ‘ä»¬å…ˆä¸çœ‹å®ƒ */
        if (enableTransitionTracing)  {
            const transition = ReactCurrentBatchConfig.transition;
            if (transition !== null && transition.name !== null)  {
                if(transition.startTime === -1) {
                    transition.startTime = now();
                }

                addTransitionToLanesMap(root, transition, lane);
            }
        }

        /** å½“å‰ FiberRoot å’Œå¾…æ›´æ–°FiberRoot ç›¸åŒæ—¶ */
        if (root === workInProgressRoot) {
            if(
                deferRenderPhaseUpdateToNextBatch || 
                (executionContext & RenderContext) === NoContext
            )
        } {
            workInProgressRootInterleavedUpdatedaLanes = mergeLanes(
                workInProgressRootInterleavedUpdatedLanes,
                lane,
            );
        }

        if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
            markRootSuspended(root, workInProgressRootRenderLanes);
        }
        /** ç¡®ä¿è°ƒåº¦ Fiber Root çš„åˆ›å»ºå’Œæ›´æ–° */
        ensureRootIsScheduled(root, eventTime);

        if(
            lane === SyncLane &&
            executionContext === NoContext &&
            (fiber.mode & ConcurrentMode) === NoMode &&
            !(__DEV__ && ReactCurrentActQueue.isBatchingLegacy)
	    ) {
    	    resetRenderTimer();
    	    flushSyncCallbacksOnlyInLegacyMode();
	    }
    }
}
```

##### 2.1.3 ensureRootIsScheduled

ensureRootIsScheduled ä¸»è¦åšäº†ä»¥ä¸‹å‡ ä»¶äº‹ï¼š

1. è·å–æ­¤æ¬¡æ›´æ–°çš„lanes
2. è·å–æ­¤æ¬¡ lane çš„æœ€é«˜ä¼˜å…ˆçº§
3. æ‰§è¡Œå¹¶å‘æˆ–åŒæ­¥ç­‰æ¨¡å¼ä¹‹ä¸€çš„ä»»åŠ¡ã€‚ï¼ˆå¹¶å‘æ¨¡å¼ä¸‹ä¸º performConcurrentWorkOnRootï¼‰

```javascript
function ensureRootIsScheduled(root, currentTime) {
    const existingCallbackNode = root.callbackNode;

    /** è§£å†³ react æµç¨‹ä¸­çš„é¥¥é¥¿é—®é¢˜ */
    markStarvedLanesAsExpired(root, currentTime);
    
    /** è·å–æœ¬æ¬¡å¤„ç†çš„ lanes */
    const nextLanes = getNextLanes(
        root,
        root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,
    );


    /** æ²¡æœ‰è¯¥å¤„ç†çš„ä»»åŠ¡ */
    if(nextLanes === NoLanes) {
        if( existingCallbackNode !== null) {
            cancelCallback(existingCallbackNode);
        }

        root.callbackNode = null;
        root.callbackPriority = NoLane;
        return;
    }

    /** è·å–è¯¥ lane æœ€é«˜ä¼˜å…ˆçº§ */
    const newCallbackPriority = getHighestPriorityLane(nextLanes);
    const existingCallbackPriority = root.callbackPriority;

    if (
        existingCallbackPriority === newCallbackPriority &&
        !(
            __DEV__ &&
            ReactCurrentActQueue.current !== null &&
            existingCallbackNode !== fakeActCallbackNode
        )
    ) {
        return;
    }

    if (existingCallbackNode != null) {
        cancelCallback(existingCallbackNode);
    }

    let newCallbackNode;
    /** æ ¹æ®ä¸åŒä¼˜å…ˆçº§è¿›è¡Œä¸åŒæ¨¡å¼ä¸‹æ›´æ–°ï¼ˆåˆå§‹åŒ–ï¼‰ä»»åŠ¡çš„è°ƒåº¦ */
    if (newCallbackPriority === SyncLane) {
        /** Legacy æ¨¡å¼ */
        if(root.tag ===  LegacyRoot) {
            scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root));
        /** Sync æ¨¡å¼ */
        } else {
            scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
        }
        if(supportMicrotasks) {
            scheduleMicrotask(() =>{
                if(
                    (executionContext & (RenderContext | CommitContext)) === NoContext
                ) {
                    flushSyncCallbacks()
                }
            });
        } else {
            scheduleCallback(ImmediateSchedulerPriority, flushSyncCallbacks);
        }
        newCallbackNode = null;
    } else {
        let schedulerPriorityLevel;
        switch (lanesToEventPriority(nextLanes)) {
            case DiscreteEventPriority:
                schedulerPriorityLevel = ImmediateSchedulerPriority;
                break;
            case ContinuousEventPriority:
                schedulerPriorityLevel = UserBlockingSchedulerPriority;
                break;
            case DefaultEventPriority:
                schedulerPriorityLevel = NormalSchedulerPriority;
                break;
            case IdleEventPriority:
                schedulerPriorityLevel = IdleSchedulerPriority;
                break;
            default:
                schedulerPriorityLevel = NormalSchedulerPriority;
                break;
        }

        newCallbackNode = scheduleCallbackNode = scheduleCallback(
            schedulerPriorityLevel,
            /** æ‰§è¡Œ Concurrent æ¨¡å¼ä¸‹çš„ Fiber æ ‘çš„æ„å»ºä»»åŠ¡  */
            performConcurrentWorkOnRoot.bind(null, root)
        );
    }
    root.callbackPriority = new CallbackPriority;
    root.callbackNode = newCallbackNode;
}
```

##### 2.1.4 performConcurrentWorkOnRoot

performConcurrentnWorkOnRoot å†…è°ƒç”¨äº† renderRootConcurrent æ¥æ¸²æŸ“ FiberRoot

```javascript
function performConcurrentWorkOnRoot(root, didTimeout) {
    if(enablePriofilerTimer && enableProfilerNestedUpdatePhase) {
        resetNestedUpdateFlag();
    }

    currentEventTime = NoTimestamp;
    currentEventTransitionLane = NoLanes;

    if((executionContext & (RenderContext | CommitContext)) !== NoContext) {
        throw new Error('Should not already be working');
    }

    const originalCallbackNode = root.callbackNode;
    const didFlushPassiveEffects =  flushPassiveEffects();

    if(didFlushPassiveEffects) {
        if(root.callbackNode !== originalCallbackNode) {
            return null;
        }
    } else {

    }

    let lanes = getNextLanes(
        root,
        root === workInProgressRoot ï¼Ÿ workInProgressRootRenderLanes : NoLanes,
    );

    if(lanes === NoLanes) {
        return null;
    }

    const exitStatus = shouldTimeSlice 
        /** Concurrentæ¨¡å¼ä¸‹æ¸²æŸ“ FiberRoot */
        ? renderRootConcurrent(root, lanes)
        : renderRootSync(root, lanes);

    /** ... */

    ensureRootIsScheduled(root, now());
}
```

##### 2.1.5 renderRootConcurrent

renderRootConcurrent åšäº†ä»¥ä¸‹å‡ ä»¶äº‹ï¼š

1. è°ƒç”¨ prepareFreshStack åˆå§‹åŒ– Fiber æ ‘æ„å»ºå·¥ä½œä¸­éœ€è¦çš„ä¸€äº›å…¨å±€å˜é‡ï¼ˆworkInProgressã€workInProgressRoot ç­‰ï¼‰ã€‚
2. åœ¨ä¸€ä¸ªæ°¸çœŸçš„ do-while å¾ªç¯é‡Œæ‰§è¡Œ workLoopConcurrent å·¥ä½œå¾ªç¯ã€‚

```javascript
function renderRootConcurrent(root, lanes) {
  const prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  const prevDispatcher = pushDispatcher();

  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    if (enableUpdaterTracking) {
      if (isDevToolsPresent) {
        const memoizedUpdaters = root.memoizedUpdaters;
        if (memoizedUpdaters.size > 0) {
          restorePendingUpdaters(root, workInProgressRootRenderLanes);
          memoizedUpdaters.clear();
        }

        movePendingFibersToMemoized(root, lanes);
      }
    }

    workInProgressTransitions = getTransitionsForLanes(root, lanes);
    resetRenderTimer();
    /** åˆå§‹åŒ–å…¨å±€å˜é‡ workInProgress å’Œ workInProgressRoot */
    prepareFreshStack(root, lanes);
  }

  if (enableSchedulingProfiler) {
    markRenderStarted(lanes);
  }

  do {
    try {
        /** å¼€å§‹ Concurrent æ¨¡å¼çš„å·¥ä½œå¾ªç¯ */
        workLoopConcurrent();
      break;
    } catch (thrownValue) {
      handleError(root, thrownValue);
    }
  } while (true);
  resetContextDependencies();

  popDispatcher(prevDispatcher);
  executionContext = prevExecutionContext;

  // Check if the tree has completed.
  if (workInProgress !== null) {
    // Still work remaining.
    if (enableSchedulingProfiler) {
      markRenderYielded();
    }
    return RootInProgress;
  } else {
    // Completed the tree.
    if (enableSchedulingProfiler) {
      markRenderStopped();
    }

    // Set this to null to indicate there's no in-progress render.
    workInProgressRoot = null;
    workInProgressRootRenderLanes = NoLanes;

    // Return the final exit status.
    return workInProgressRootExitStatus;
  }
}
```
##### 2.1.6 åˆ›å»º workInProgress
prepareFreshStack ä¸»è¦çš„ä»»åŠ¡å°±æ˜¯åˆ›å»º workInProgress , workInProgress æ—¶æ‰§è¡Œä¸€æ¬¡æ›´æ–°ä»»åŠ¡çš„æ•°æ®å•å…ƒã€‚


```javascript
function prepareFreshStack(root, lanes) {
  root.finishedWork = null;
  root.finishedLanes = NoLanes;

  const timeoutHandle = root.timeoutHandle;
  if (timeoutHandle !== noTimeout) {
    // The root previous suspended and scheduled a timeout to commit a fallback
    // state. Now that we have additional work, cancel the timeout.
    root.timeoutHandle = noTimeout;
    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
    cancelTimeout(timeoutHandle);
  }

  if (workInProgress !== null) {
    let interruptedWork = workInProgress.return;
    while (interruptedWork !== null) {
      const current = interruptedWork.alternate;
      unwindInterruptedWork(
        current,
        interruptedWork,
        workInProgressRootRenderLanes,
      );
      interruptedWork = interruptedWork.return;
    }
  }
  workInProgressRoot = root;
  const rootWorkInProgress = createWorkInProgress(root.current, null);
  workInProgress = rootWorkInProgress;
  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
  workInProgressRootExitStatus = RootInProgress;
  workInProgressRootFatalError = null;
  workInProgressRootSkippedLanes = NoLanes;
  workInProgressRootInterleavedUpdatedLanes = NoLanes;
  workInProgressRootRenderPhaseUpdatedLanes = NoLanes;
  workInProgressRootPingedLanes = NoLanes;
  workInProgressRootConcurrentErrors = null;
  workInProgressRootRecoverableErrors = null;

  enqueueInterleavedUpdates();

  return rootWorkInProgress;
}
```

createWorkInProgress è´Ÿè´£åˆ›å»º workInProgressï¼ˆä¹Ÿæ˜¯ä¸€ä¸ª Fiberï¼‰ï¼Œå¹¶å°†å½“å‰ fiber çš„æ‰€æœ‰å±æ€§å€¼å¤åˆ¶ç»™ workInProgressã€‚è¯¥ workInProgress å°±æ›¿ä»£å½“å‰ fiber æˆä¸ºæ­¤æ¬¡å¾…å¤„ç†çš„æ•°æ®å•å…ƒã€‚

```javascript
export function createWorkInProgress(current: Fiber, pendingProps: any): Fiber {
  let workInProgress = current.alternate;

  /** å½“ workInProgress ä¸å­˜åœ¨æ—¶åˆ›å»º workInProgress */
  if (workInProgress === null) {
    workInProgress = createFiber(
      current.tag,
      pendingProps,
      current.key,
      current.mode,
    );
    workInProgress.elementType = current.elementType;
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  
  /** å½“ workInProgress å­˜åœ¨æ—¶é‡å¤åˆ©ç”¨ä¸Šä¸€æ¬¡çš„ workInPorgress */
  } else {
    workInProgress.pendingProps = pendingProps;
    workInProgress.type = current.type;

    workInProgress.flags = NoFlags;

    workInProgress.subtreeFlags = NoFlags;
    workInProgress.deletions = null;

    if (enableProfilerTimer) {
      workInProgress.actualDuration = 0;
      workInProgress.actualStartTime = -1;
    }
  }

  workInProgress.flags = current.flags & StaticMask;
  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;

  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;

  const currentDependencies = current.dependencies;
  workInProgress.dependencies =
    currentDependencies === null
      ? null
      : {
          lanes: currentDependencies.lanes,
          firstContext: currentDependencies.firstContext,
        };

  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;

  if (enableProfilerTimer) {
    workInProgress.selfBaseDuration = current.selfBaseDuration;
    workInProgress.treeBaseDuration = current.treeBaseDuration;
  }

  return workInProgress;
}
```
