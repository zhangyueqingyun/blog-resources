# ES13 (ECMA2022) 深度解读

## 一、前言

[ECMA2022 (ES13)](https://tc39.es/ecma262/) 已经是 ECMAScript 语言的第 13 个版本啦！  
我们来看看这个版本为我们带来了哪些新特性吧！

## 二、概览

ES13 为我们带来了6个新特性：

1. 模块顶层作用域支持 await 表达式。
2. 新增私有类元素、静态块；in 操作符支持私有类元素。
3. 正则新增 d 标志和其对应的 hasIndices 属性，提供了获取捕获组开始索引和结束索引的方法。
4. Error 实例增加 cause 属性，可携带更多错误信息。
5. Strings、Arrays、TypedArrays 新增 at 方法，支持关联访问。
6. Object.hasOwn 代替 Object.prototype.hasOwnProperty，判断是对象是否含有属性。

接下来的内容将详细介绍每个新特性。

## 三、 顶层 await 表达式 

以往我们总是在异步函数体内使用 await 表达式，自 ES13 后，我们也可以在一个模块的顶层使用它了。  

在模块顶层使用 await 表达式

```javascript
// 异步加载资源
import {fetchPerson} from '@/services/person';
const person = await fetchPerson();

// 异步加载组件
await import('your-component-path'); 
```

在异步函数中使用 await 表达式


```javascript
import {get} from '@/utils/request';

export async function getPerson() {
    const person = await get('/person');
    return person;
}
```

### 错误用法

在以下几种语句内的 Formal Parameters 中使用 Await 表达式，会引发静态句法的语义错误。
1. 异步函数声明 (AsyncFunctionDeclaration)
2. 异步函数表达式 (AsyncFunctionExpression)
3. 异步生成器函数表达式 (AsyncGeneratorExpression)
4. Await 表达式内部 (AwaitExpression)

### 特殊情况

在早期，await 没有出现在关键字中，为了兼容旧代码，在一些特殊的 await 作为参数出现的情况下，它会被解释为标识符。如下所述：

1. 当 await 出现在 AsyncFunctionBody 和 AsyncFunctionDeclaration、AsyncFunctionExpression、AsyncGeneratorDeclaration、AsyncGeneratorExpression 的 FormalParameter 外部时，await 会被解析为标识符。
2. 当 await 出现在 FunctionExpression, GeneratorExpression, AsyncGeneratorExpression 的 BindingIdentifier 中时，await 会被解析为标识符。

## 四、 class 新特性

### 4.1 私有类元素

在类的定义中，以 "#" 开头的标识符为私有标识符，由私有标识符定义的类元素被称为私有类元素，私有类元素只能在类中才能被访问到。类的属性、静态属性、方法、静态方法、访问器、静态访问器都可以被定义为私有类元素。

```javascript
class ClassA {
    // 私有属性
    #privateProperty;

    // 静态私有属性
    static #privateStaticProperty;

    // 静态私有 Getter
    static get #privateStaticGet() {
        return 'private-static-get';
    }

    // 静态私有 Setter
    static set #privateStaticSet(val) {
    }

    // 静态私有方法
    static #privateStaticMethod() {
        return 'private-static-method'
    }

    constructor(propertyValue) {
        // 初始化私有属性
        this.#privateProperty = propertyValue;
    }

    // 私有 Get
    get #privateGet() {
        return 'private-get'
    }

    // 私有 Set
    set #privateSet() {
    }

    // 私有方法
    #privateMethod() {
        return 'private-method'
    }
} 
```

```javascript
class PersonClass {
	static #num = 0;
	static #female_num = 0;

	static #compareSexNum() {
		const male_num = this.#num - this.#female_num;
		return this.female_num > this.male_num;
	}

	static needMale() {
		return this.#compareSexNum()
	}

	static isFull() {
		return this.#num > 100;
	}

	constructor(name, age, sex) {
		PersonClass.#num++;
		this.name = name;
		this.#age = age;
		this.#sex = sex;
		this.#recordFemaleNum();
	}

	#recordFemaleNum() {
		if(this.#sex === female) {
			PersonClass.#female_num++;
		}
	}

	isAdult() {
		return this.#age > 18;
	}
}
```

### 4.2 静态块

静态块是为了丰富静态属性的初始化而出现的，它可以使静态属性的初始化操作更加灵活。我们可以再静态块中使用一些列的语句来完成静态变量的初始化。

```javascript
class Person {
	static num;
	static {
		try {
			this.num = getOldPersonNum();
		} catch {
			console.log('Person num initialization error.')
		}

	}
}
```

一个类可以具有多个静态类属性块，他们的执行顺序是根据 Person 类的定义块中定义静态变量和静态块的顺序执行的。 

如果有父类，我们可以利用 super 在静态块中访问父类的属性。父类的所有静态变量和静态块会先于子类的执行。

我们可以利用 this 访问类中的其他静态属性（包括私有属性）。

### 4.3 私有化 in 操作符

我们知道 in 操作符可以帮我们判断实例中是否存在属性，当新增了私有化类元素后，我们也可以和下面例子一样，在类定义内使用 in 操作符判断私有化类元素存在与否。

```javascript
class Person {
	#age;

	static hasAgeProperty(person) {
		return #age in person
	}

	constructor(name, age) {
		this.name = name;
		this.#age = age;
	}
}

const person = new Person('zhangyueqingyun', 1);
Person.hasAgeProperty(person);
```

> ##### 2.1.2 私有化属性标准解析
>
> 下面我们来看看标准中是如何表达私有化属性的~ 
>
> 首先，定义了私有标识符，它由井号键开头，后接普通标识符。
>
> ```
> PrivateIdentifier::
>     # IdentifierName
> ```
> 
> 类元素名的定义中发现了私有标识符的出现，即类元素名可以用私有标识符定义。
> 
> ```
> ClassElementName:
> 	PropertyName
> 	PrivateIdentifier
> ```
> 
> 类元素包含：
> 
> - 方法
> - 静态方法 
> - 属性
> - 静态属性
> - 类静态块
> 
> ```
> ClassElement:
> 	MethodDefination
> 	static MethodDefination
> 	FieldDefination
> 	static FieldDefination
> 	ClassStaticBlock
> ```
> 
> 而方法的定义又包含：
> 
> 1. 类方法定义表达式 ClassElementName (UniqueFormalParameters) { FunctionBody }
> 2. 生成器方法
> 3. 异步方法
> 4. 异步生成器方法
> 5. get 访问器
> 6. set 访问器
> 
> ``` 
> MethodDefination: 
> 	ClassElementName (UniqueFormalParameters) { FunctionBody }
> 	GeneratorMethod
> 	AsyncMethod
> 	AsyncGeneratorMethod
> 	get ClassElementName 
> 	set ClassElementName
> ```
> 
> 根据以上标准定义的推导，类属性、方法、访问器，类的静态属性、方法、访问器都可以通过私有标识符声明为类的私有属性。

### 3. 正则 /d 标识

对字符串的处理我们常用到 Javascript 的内置对象 String 和 正则表达式 RegExp 。正则表达式有很多标志，它决定了正则状态机的一些行为，和输出的结果。

创建正则实例时使用 d 标志，实例的属性 hasIndices 会被设置为 true, 当实例的 hasIndices 为 true 时，正则表达式的匹配结果将包含每个捕获组捕获子字符串的开始和结束的游标。

```
const str = "today is saturday";
const reg = /saturday/d;

const [start, end] = reg.exec(str).indices[0];

console.log([start, end]); // [9, 16]
```

### 4. Error 对象的 cause 属性

在 ES2022 标准之前，Error 对象只能传递一个消息信息，现在，我们可以利用 cause 属性在错误发生的同时传递更多的信息。

```javascript
try {
	/** some statement */
} catch (error) {
	throw new Error('failed message', { cause: error });
}
```

cause 可以是自己指定的任意类型的数据，方便我们在上下文中传递错误信息。


### 5. Strings、Arrays、TypedArrays 的 at 方法，它允许了关联访问。


```javascript
const array = [5, 12, 8, 130, 44];

array.at[-2]; // 130
```

### 6. Object.hasOwn

判断这个实例上是否有属性，代替之前的 hasOwnProperty。 

```javascript
const object = {
	count: 1
};

Object.hasOwn(object, 'count'); // true
Object.hasOwn(object, 'toString'); // false
Object.hasOwn(object, 'property'); // false
```

## 三、结尾

这些就是 ES13 中所有的新特性啦！ 如有错误，欢迎小伙伴们指正~ @V@ ~


作者的信息~

- github: https://github.com/zhangyueqingyun
- wechat: abcde-ovo-yz