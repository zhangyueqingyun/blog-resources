# 作用域和内存管理
## Javascript 运行时环境
Javascript 运行时环境就是 JS 引擎，包括 v8、Firefox 的 SpiderMonkey、Safari 的 JavaScriptCore，另外还有轻量化的 QuickJS、Hermes 等。

## JS 引擎
当你声明一个变量或者方程时，内存会被分配到堆中。当你运行代码时，方程会被压栈到 call stack 中，就像常见栈数据结构的先入后出（last in）过程一样。

### 运行时内存
#### GO 全局对象
- 所有作用域都可以访问全局对象
- 对象里会包含一些全局的方法和类
- 其中有一个 window 属性指向自身
- 该对象中会收集我们上面全局定义的变量
#### 函数执行栈
Javascrip 引擎在执行一段代码前，会先创建对应的执行上下文（EC, Execution Context),该执行上下文负责存储 VO、AO、Scope、this。同时也创建执行上下文栈（ECStack, Execution Context Stack）来管理执行上下文的推入和弹出。
##### 全局执行上下文 （GEC)
先执行全局代码块，在执行全局代码块时会构建全局执行上下文，然后将全局执行上下文放入执函数执行栈中执行。

##### 函数执行上下文 (FEC)
在执行的过程中遇到函数，就会根据函数体创建一个函数执行上下文（Functional Execution Context，并且加入到函数执行上下文栈中(ECS)。

函数执行上下文包含
- VO
- [[SCOPE]] 作用域链
- this 指向

#### AO 函数的活动对象
定义在全局上下文中，存储全局变量和函数。

帮助 js 引擎在引用变量的时候能够去顺利找到变量。并且它们之间的联系可以实现作用域链。
#### VO 函数的变量对象
定义在全局上下文中，存储全局变量和函数。
#### Scope
Scope 定义在执行上下文中，就是所谓的作用域，存储在其中的一个个 AO 和 VO 按队列链接成了所谓的作用域链。

[[scope]] 定义在函数中，在函数创建时会保存当前父级函数的 [[scope]] 以及父级函数执行上下文的 AO。

闭包就是返回的内部函数的 [[scope]] 保存了下来。
#### 堆
存储引用类型。
#### 静态存储区
存储静态变量、字符串等。
#### 任务队列
异步任务队列存储区，分为宏任务队列和微任务队列。

### 垃圾回收机制
v8 引擎的垃圾回收采用标记清除法与分代回收法
#### 新生代
对象的存活时间较短，新生对象或只经过一次垃圾回收的对象。

回收新生代对象主要采用复制算法（Scavenge 算法）加标记整理算法。而 Scavenge 算法的具体实现，主要采用了 Cheney 算法。

将堆内存分为两个区，一个使用状态的空间称为使用区。一个处于闲置状态的空间称为空闲区。新加入的对象都会被存放到使用区，当使用区快被写满时，就执行一次垃圾回收操作。

- 先对使用区中的活动做标记
- 标记完成后，将使用区的活动对下那个复制进空闲区并进行排序
- 将原先使用区对象占用的空间释放
- 最后进行角色互换，把空闲区变为使用区，使用区变为空闲区。
#### 老生代
对象存活时间较长，经历过一次或多次垃圾回收的对象。

回收老生代对象主要采用标记清除、标记整理、增量标记的算法，主要使用标记清除算法，只有在内存分配不足时，采用标记整理算法来解决这个问题。
##### 增量标记
并行策略虽然可以增加垃圾回收的效率，对于新生代这样存放较小对象的回收器能有很好的优化，但其实还是全停顿式的。对于存放较大对象的老生代来说，这些较大对象 GC 标记。如果执行 JS 任务时刚被标记好的对象引用又被修改了该当如何？ V8 解决这两个问题的方法分别是 三色标记法和写屏障。
###### 三色标记法
- 黑色：已经扫描了节点和子节点
- 灰色：已经扫描了节点未扫描子节点
- 白色：未扫描
###### 写屏障
每当引用变化后，需要立刻对被引用节点进行着色：即白的立刻染灰，灰的和黑的节点不变