# 红黑树

红黑树是一颗自平衡的二叉搜索树，通过在节点上赋予颜色属性、必须满足的颜色相关的特殊性质、改变树结构的同时进行调整使之满足条件而事自身达到自平衡，

## 红黑树必须满足的条件

### 1 红黑树特有的性质

- 每个结点是红色或者黑色的。
- 根节点是黑色的。
- 叶子节点是黑色的（Nill 节点）。
- 红色节点的两个孩子是黑色的。
- 每个叶节点到根节点的路径包含相同数目的黑色节点。 

### 2 二叉搜索树的性质

- 左子树上所有的节点值均小于等于根节点
- 右子树上所有节点的值均大于等于根节点
- 左右子树递归上为二叉搜索树

## 红黑树的性质

1. 一颗有 n 个内部节点的红黑树高度最多为 2lg(n+1)。
2. 动态集合操作 SEARCH、MINIMUM、MAXIMUM、SUCCESSOR 可以在 O(lgn) 内执行。

## 红黑树的基本操作

红黑树的常见操作有旋转、插入、删除，我们分别来看一下这几个操作。

### 1 旋转

旋转操作是自平衡二叉树的基本操作，通过它可以位置平衡二叉树的性质。旋转操作又分为左旋和右旋，我们来看一下具体的操作。

#### 1.1 左旋操作

当节点右子树的高度大于左子树的高度时，通过左旋可以降低右子树的高度，增加左子树的高度，代码如下：

```javascript
function leftRotate(tree, node) 
{
    const right = node.right; 
    node.right = right.left;
    
    if(right?.left) 
    {
        right.left.parent = node;        
    }

    right.parent = node.parent;
    if(!node?.parent) 
    {
        tree.root = right;
    }
    else if(node === node.parent.left)
    {
        node.parent.left = right;
    }
    else 
    {
        node.parent.right = right;
    }

    right.left = node;
    node.parent = right;
}
```

### 1.2 插入操作

红黑树的插入操作的时间复杂度为 O(lgn)，具体过程为：

1. 和插入二叉搜索树相同的操作，使其满足二叉搜索树的性质。
2. 利用左旋和优先调整插入后树的性质，使其满足红黑树的性质。

代码如下：

```javascript
function insert(tree, node) 
{
    let current = tree.root;

    while(current)
    {
        node.parent = current;
        current = node.value < current.value ? current.left : current.right;
    }

    const {parent} = node;
    if(!parent)
    {
        tree.root = node;   
    }
    else if(node.value < parent.value)
    {
        parent.left = node;
    }
    else 
    {
        parent.right = node;
    }

    node.color = RED;
    fixup(tree, node);
}

function fixup(tree, node) 
{
    while(node.parent.color === RED) 
    {
        if(node.parent == node.parent.parent.left)
        {
            const parent = node.parent;
            const grand = node.parent.parent;
            const uncle = grand.right;
            if(uncle.color == RED)
            {
                node.parent.color= BLACK;
                uncle.color = BLACK;
                grand.color = RED;
                NODE = grand;
            }
            else if(node === parent.right)
            {
                node = parent;
                leftRotate(tree, node);
            }
            else 
            {
                parent.color = BLACK;
                grand.color = RED;
                rightRotate(tree, grand);
            }
        }
        else 
        {
            /** 左右换一下 */
        }
    }
    tree.root.color = BLACK;
}
```

### 1.3 删除操作

红黑树的删除操作的时间复杂度也为 O(lgn)。

```javascript 
function transplant(tree, uNode, vNode) 
{
    if(!uNode.parent)
    {
        tree.root = vNode;
    }
    else if (uNode == uNode.parent.left) 
    {
        uNode.parent.left = vNode;
    }
    else 
    {
        vNode.parent = uNode.parent;
    }
}

function delete(tree, node)
{
    const color = node.color;
    let fixupNode;
    if(!node.left)
    {
        fixupNode = node.right;
        transplant(tree, node, node.right);
    }
    else if (!node.right)
    {
        fixupNode = node.left;
        transplant(tree, node, node.left);
    }
    else 
    {
        const min = minimum(node.right);
        color = min.color;
        fixupNode = min.right;
        if(min.parent === node)
        {
            min.right.parent = min; 
        }
        else  
        {
            transplant(tree, min, min.right);
            min.right = node.right;
            min.right.parent = min;
        }
        transplant(tree, node, min);
        min.left = node.left;
        min.left.parent = min;
        min.color = node.color;
    }
    if(color === BLACK) 
    {
        fixup(tree, fixupNode);
    }
}

function fixup(tree, node)
{
    while(node !== tree.root && node.color == BLACK)
    {
        let parent = node.parent;
        if(node == parent.left)
        {
            let brother = parent.right;
            if(brother.color == RED)
            {
                brother.color = BLACK;
                parent.color = RED;
                leftRotate(tree, parent);
                parent = node.parent;
                brother = parent.right;
            }

            if(brother.left.color === BLACK && brother.right.color === BLACK) 
            {
                brother.color = RED;
                node = node.parent;
                parent = node.parent;
            }
            else if(brother.right.color === BLACK) 
            {
                brother.left.color = black;
                brother.color = RED;
                rightRotate(tree, brother);
                parent = node.parent;
                brother = parent.right;
            }
            else 
            {
                brother.color = parent.color;
                parent.color = BLACK;
                brother.right.color = BLACK;
                node = tree.root;
            }
        }
        else 
        {
            /** 左右换一下 */
        }
    }
    node.color = BLACK;
}
```